<!-- Generated by documentation.js. Update this documentation by updating the source code. -->

### Table of Contents

*   [][1]
    *   [Examples][2]
*   [Terminal3DPage][3]
*   [handleFocusAndSelectSystem][4]
    *   [Parameters][5]
*   [][6]
*   [AnnotationDialogProps][7]
    *   [Properties][8]
*   [AnnotationDialog][9]
    *   [Parameters][10]
*   [useEffect][11]
*   [useEffect][12]
    *   [Parameters][13]
    *   [Examples][14]
*   [handleConfirm][15]
*   [][16]
*   [CameraControlsPanelProps][17]
    *   [Properties][18]
*   [CameraControlsPanel][19]
    *   [Parameters][20]
*   [][21]
*   [ColorModeSelectorProps][22]
    *   [Properties][23]
*   [ColorModeSelector][24]
    *   [Parameters][25]
*   [][26]
*   [CommandHistoryPanelProps][27]
    *   [Properties][28]
*   [CommandHistoryPanel][29]
    *   [Parameters][30]
*   [][31]
*   [InfoPanelProps][32]
    *   [equipment][33]
    *   [annotation][34]
    *   [onClose][35]
    *   [onOpenAnnotationDialog][36]
    *   [onDeleteAnnotation][37]
    *   [onOperationalStateChange][38]
    *   [availableOperationalStatesList][39]
    *   [onProductChange][40]
    *   [availableProductsList][41]
*   [InfoPanel][42]
    *   [Parameters][43]
*   [handleDeleteClick][44]
*   [formattedDate][45]
*   [][46]
*   [LayerManagerProps][47]
    *   [Properties][48]
*   [LayerManager][49]
    *   [Parameters][50]
*   [][51]
*   [MainSceneAreaProps][52]
    *   [Properties][53]
*   [MainSceneArea][54]
    *   [Parameters][55]
*   [][56]
*   [SidebarContentLayoutProps][57]
    *   [Properties][58]
*   [SidebarContentLayout][59]
    *   [Parameters][60]
*   [Terminal][61]
*   [SiteHeader][62]
*   [][63]
    *   [Examples][64]
*   [ThreeSceneProps][65]
    *   [Properties][66]
*   [ThreeScene][67]
    *   [Parameters][68]
*   [THEMES][69]
*   [ChartConfig][70]
    *   [Examples][71]
*   [Form][72]
    *   [Parameters][73]
    *   [Examples][74]
*   [][75]
*   [useSidebar][76]
*   [SidebarProvider][77]
    *   [defaultOpen][78]
    *   [open][79]
    *   [onOpenChange][80]
*   [Sidebar][81]
    *   [side][82]
    *   [variant][83]
    *   [collapsible][84]
*   [SidebarTrigger][85]
*   [SidebarRail][86]
*   [SidebarInset][87]
*   [SidebarInput][88]
*   [SidebarHeader][89]
*   [SidebarFooter][90]
*   [SidebarSeparator][91]
*   [SidebarContent][92]
*   [SidebarGroup][93]
*   [SidebarGroupLabel][94]
*   [SidebarGroupAction][95]
*   [SidebarGroupContent][96]
*   [SidebarMenu][97]
*   [SidebarMenuItem][98]
*   [SidebarMenuButton][99]
    *   [isActive][100]
    *   [tooltip][101]
*   [SidebarMenuAction][102]
    *   [showOnHover][103]
*   [SidebarMenuBadge][104]
*   [SidebarMenuSkeleton][105]
    *   [showIcon][106]
*   [SidebarMenuSub][107]
*   [SidebarMenuSubItem][108]
*   [SidebarMenuSubButton][109]
    *   [size][110]
    *   [isActive][111]
*   [Equipment][112]
*   [Equipment][113]
*   [Equipment][114]
    *   [Examples][115]
*   [Equipment][116]
*   [Equipment][117]
    *   [Properties][118]
*   [initialEquipment][119]
*   [initialLayers][120]
*   [initialAnnotations][121]
*   [THREE][122]
*   [THREE][123]
    *   [Examples][124]
*   [THREE][125]
*   [THREE][126]
    *   [Examples][127]
*   [THREE][128]
    *   [Examples][129]
*   [THREE][130]
    *   [Examples][131]
*   [THREE][132]
    *   [Parameters][133]
    *   [Examples][134]
*   [THREE][135]
    *   [Examples][136]
*   [getCharNumericValue][137]
    *   [Parameters][138]
*   [getEquipmentColor][139]
    *   [Parameters][140]
*   [EquipmentFilterCriteria][141]
    *   [Properties][142]
*   [getFilteredEquipment][143]
    *   [Parameters][144]
*   [equipmentRepository][145]
    *   [getEquipmentByTag][146]
        *   [Parameters][147]
    *   [getAllEquipment][148]
    *   [addEquipment][149]
        *   [Parameters][150]
    *   [updateEquipment][151]
        *   [Parameters][152]
    *   [deleteEquipment][153]
        *   [Parameters][154]
*   [annotationRepository][155]
    *   [getAnnotationByEquipmentTag][156]
        *   [Parameters][157]
    *   [getAllAnnotations][158]
    *   [addOrUpdateAnnotation][159]
        *   [Parameters][160]
    *   [deleteAnnotation][161]
        *   [Parameters][162]
    *   [initializeAnnotations][163]
        *   [Parameters][164]
*   [calculateViewForMeshes][165]
    *   [Parameters][166]
*   [createGeometryForItem][167]
    *   [Parameters][168]
*   [updateLabelRendererSize][169]
    *   [Parameters][170]
*   [UpdateAnnotationPinsParams][171]
    *   [Properties][172]
*   [updateAnnotationPins][173]
    *   [Parameters][174]
*   [][175]
*   [setOutlinePassObjects][176]
    *   [Parameters][177]
*   [applyOutlinePassStyle][178]
    *   [Parameters][179]
*   [setupPostProcessing][180]
    *   [Parameters][181]
*   [updatePostProcessingSize][182]
    *   [Parameters][183]
*   [updateOutlineEffect][184]
    *   [Parameters][185]
*   [setupLighting][186]
    *   [Parameters][187]
*   [setupGroundPlane][188]
    *   [Parameters][189]
*   [setupRenderPipeline][190]
    *   [Parameters][191]
*   [UpdateEquipmentMeshesParams][192]
    *   [Examples][193]
*   [updateEquipmentMeshesInScene][194]
    *   [Parameters][195]
*   [UseAnimationLoopProps][196]
    *   [Properties][197]
*   [useAnimationLoop][198]
    *   [Parameters][199]
*   [][200]
    *   [Parameters][201]
    *   [Examples][202]
*   [UseAnnotationManagerProps][203]
    *   [Properties][204]
*   [UseAnnotationManagerProps][205]
    *   [Properties][206]
*   [UseAnnotationManagerReturn][207]
    *   [Properties][208]
*   [UseAnnotationManagerReturn][209]
    *   [Properties][210]
*   [useAnnotationManager][211]
    *   [Parameters][212]
*   [useAnnotationManager][213]
    *   [Parameters][214]
*   [refreshAnnotationsFromRepo][215]
*   [refreshAnnotationsFromRepo][216]
*   [handleOpenAnnotationDialog][217]
    *   [Parameters][218]
*   [handleOpenAnnotationDialog][219]
    *   [Parameters][220]
*   [handleSaveAnnotation][221]
    *   [Parameters][222]
*   [handleSaveAnnotation][223]
    *   [Parameters][224]
*   [handleDeleteAnnotation][225]
    *   [Parameters][226]
*   [handleDeleteAnnotation][227]
    *   [Parameters][228]
*   [getAnnotationForEquipment][229]
    *   [Parameters][230]
*   [getAnnotationForEquipment][231]
    *   [Parameters][232]
*   [UseAnnotationPinRendererProps][233]
*   [useAnnotationPinRenderer][234]
    *   [Parameters][235]
*   [][236]
    *   [Parameters][237]
    *   [Examples][238]
*   [defaultInitialCameraPosition][239]
*   [defaultInitialCameraPosition][240]
*   [defaultInitialCameraLookAt][241]
*   [defaultInitialCameraLookAt][242]
*   [UseCameraManagerProps][243]
*   [UseCameraManagerProps][244]
*   [UseCameraManagerReturn][245]
    *   [Properties][246]
*   [UseCameraManagerReturn][247]
    *   [Properties][248]
*   [useCameraManager][249]
    *   [Parameters][250]
*   [useCameraManager][251]
    *   [Parameters][252]
*   [handleSetCameraViewForSystem][253]
    *   [Parameters][254]
*   [handleSetCameraViewForSystem][255]
    *   [Parameters][256]
*   [handleCameraChangeFromScene][257]
    *   [Parameters][258]
*   [handleCameraChangeFromScene][259]
    *   [Parameters][260]
*   [onSystemFramed][261]
*   [onSystemFramed][262]
*   [Command][263]
    *   [Examples][264]
*   [Command][265]
    *   [Properties][266]
*   [CommandHistoryState][267]
    *   [Properties][268]
*   [UseCommandHistoryReturn][269]
    *   [Properties][270]
*   [useCommandHistory][271]
    *   [Parameters][272]
*   [executeCommand][273]
    *   [Parameters][274]
*   [undo][275]
*   [redo][276]
*   [][277]
    *   [Examples][278]
*   [UseEquipmentDataManagerReturn][279]
    *   [Properties][280]
*   [UseEquipmentDataManagerReturn][281]
    *   [Properties][282]
*   [useEquipmentDataManager][283]
*   [useEquipmentDataManager][284]
*   [refreshEquipmentData][285]
*   [refreshEquipmentData][286]
*   [handleOperationalStateChange][287]
    *   [Parameters][288]
*   [handleOperationalStateChange][289]
    *   [Parameters][290]
*   [handleProductChange][291]
    *   [Parameters][292]
*   [handleProductChange][293]
    *   [Parameters][294]
*   [UseEquipmentRendererProps][295]
    *   [Examples][296]
*   [useEquipmentRenderer][297]
    *   [Parameters][298]
*   [][299]
*   [UseEquipmentSelectionManagerProps][300]
    *   [Properties][301]
*   [UseEquipmentSelectionManagerReturn][302]
    *   [Properties][303]
*   [useEquipmentSelectionManager][304]
    *   [Parameters][305]
*   [handleEquipmentClick][306]
    *   [Parameters][307]
*   [handleSetHoveredEquipmentTag][308]
    *   [Parameters][309]
*   [selectTagsBatch][310]
    *   [Parameters][311]
*   [][312]
    *   [Examples][313]
*   [UseFilterManagerProps][314]
    *   [Properties][315]
*   [UseFilterManagerReturn][316]
    *   [Properties][317]
*   [useFilterManager][318]
    *   [Parameters][319]
*   [availableSistemas][320]
*   [availableAreas][321]
*   [filteredEquipment][322]
*   [][323]
    *   [Examples][324]
*   [UseLayerManagerProps][325]
*   [UseLayerManagerReturn][326]
    *   [Properties][327]
*   [useLayerManager][328]
    *   [Parameters][329]
*   [handleToggleLayer][330]
    *   [Parameters][331]
*   [raycaster][332]
    *   [Examples][333]
*   [useMouseInteractionManager][334]
    *   [Parameters][335]
*   [processSceneClickInternal][336]
*   [processSceneMouseMoveInternal][337]
*   [][338]
    *   [Examples][339]
*   [UseSceneOutlineProps][340]
    *   [Properties][341]
*   [useSceneOutline][342]
    *   [Parameters][343]
*   [UseSceneSetupProps][344]
    *   [Properties][345]
*   [UseSceneSetupReturn][346]
    *   [Properties][347]
*   [useSceneSetup][348]
    *   [Parameters][349]
*   [][350]
    *   [Examples][351]
*   [][352]
    *   [Examples][353]
*   [][354]
    *   [Examples][355]
*   [useRef][356]
    *   [Examples][357]
*   [useRef][358]
    *   [Examples][359]
*   [useRef][360]
    *   [Examples][361]
*   [useRef][362]
    *   [Examples][363]
*   [UseThreeCoreProps][364]
    *   [Properties][365]
*   [UseThreeCoreReturn][366]
    *   [Properties][367]
*   [useThreeCore][368]
    *   [Parameters][369]
*   [UseThreeOrbitControlsProps][370]
    *   [Properties][371]
*   [UseThreeOrbitControlsReturn][372]
    *   [Properties][373]
*   [useThreeOrbitControls][374]
    *   [Parameters][375]
*   [UseThreeRenderersProps][376]
    *   [Properties][377]
*   [UseThreeRenderersReturn][378]
    *   [Properties][379]
*   [useThreeRenderers][380]
    *   [Parameters][381]
*   [UseThreeResizeProps][382]
    *   [Properties][383]
*   [useThreeResize][384]
    *   [Parameters][385]
*   [UseThreeSceneElementsProps][386]
    *   [Properties][387]
*   [UseThreeSceneElementsReturn][388]
    *   [Properties][389]
*   [useThreeSceneElements][390]
    *   [Parameters][391]
*   [Layer][392]
    *   [Properties][393]
*   [CameraState][394]
*   [SystemView][395]
*   [SystemViewOptions][396]
    *   [Properties][397]
*   [TargetSystemInfo][398]
    *   [Properties][399]
*   [Annotation][400]
    *   [Properties][401]
*   [ColorMode][402]

##

*   **See**: [https://github.com/Dicommunitas/ThreeJS\_Terminal\_3D/blob/main/documentation/api/components/main-scene-area/README.md][403] Para a área principal da cena.
*   **See**: [https://github.com/Dicommunitas/ThreeJS\_Terminal\_3D/blob/main/documentation/api/components/ui/sidebar/README.md][404] Para a barra lateral de controles.
*   **See**: [https://github.com/Dicommunitas/ThreeJS\_Terminal\_3D/blob/main/documentation/api/components/annotation-dialog/README.md][405] Para o diálogo de anotações.
*   **See**: [https://github.com/Dicommunitas/ThreeJS\_Terminal\_3D/blob/main/documentation/api/hooks/use-command-history/README.md][406] Para o gerenciamento de histórico de comandos.
*   **See**: [https://github.com/Dicommunitas/ThreeJS\_Terminal\_3D/blob/main/documentation/api/hooks/use-equipment-data-manager/README.md][407] Para o gerenciamento de dados de equipamentos.
*   **See**: [https://github.com/Dicommunitas/ThreeJS\_Terminal\_3D/blob/main/documentation/api/hooks/use-camera-manager/README.md][408] Para o gerenciamento da câmera.
*   **See**: [https://github.com/Dicommunitas/ThreeJS\_Terminal\_3D/blob/main/documentation/api/hooks/use-filter-manager/README.md][409] Para o gerenciamento de filtros.
*   **See**: [https://github.com/Dicommunitas/ThreeJS\_Terminal\_3D/blob/main/documentation/api/hooks/use-annotation-manager/README.md][410] Para o gerenciamento de anotações.
*   **See**: [https://github.com/Dicommunitas/ThreeJS\_Terminal\_3D/blob/main/documentation/api/hooks/use-equipment-selection-manager/README.md][411] Para o gerenciamento de seleção de equipamentos.
*   **See**: [https://github.com/Dicommunitas/ThreeJS\_Terminal\_3D/blob/main/documentation/api/hooks/use-layer-manager/README.md][412] Para o gerenciamento de camadas.

### Examples

```javascript
// Diagrama de Interação de Alto Nível da Terminal3DPage:
\`\`\`mermaid
graph LR
    Terminal3DPage["Terminal3DPage (Página Principal)"] --> H_CmdHistory["useCommandHistory (Hook Histórico)"];
    Terminal3DPage --> H_EquipData["useEquipmentDataManager (Hook Dados Equip.)"];
    Terminal3DPage --> H_CameraMgr["useCameraManager (Hook Câmera)"];
    Terminal3DPage --> H_FilterMgr["useFilterManager (Hook Filtros)"];
    Terminal3DPage --> H_AnnotMgr["useAnnotationManager (Hook Anotações)"];
    Terminal3DPage --> H_EquipSelectMgr["useEquipmentSelectionManager (Hook Seleção)"];
    Terminal3DPage --> H_LayerMgr["useLayerManager (Hook Camadas)"];

    Terminal3DPage --> MainSceneArea_Comp["MainSceneArea (Comp. Área da Cena)"];
    Terminal3DPage --> Sidebar_Comp["Sidebar (Comp. Barra Lateral)"];
    Terminal3DPage --> AnnotationDialog_Comp["AnnotationDialog (Comp. Diálogo Anotação)"];

    MainSceneArea_Comp --> ThreeScene_Comp["ThreeScene (Comp. Cena 3D)"];
    MainSceneArea_Comp --> InfoPanel_Comp["InfoPanel (Comp. Painel Info)"];
    Sidebar_Comp --> SidebarContentLayout_Comp["SidebarContentLayout (Comp. Conteúdo Sidebar)"];

    subgraph "Hooks de Gerenciamento de Estado da Aplicação"
      H_CmdHistory;
      H_EquipData;
      H_CameraMgr;
      H_FilterMgr;
      H_AnnotMgr;
      H_EquipSelectMgr;
      H_LayerMgr;
    end

    subgraph "Componentes de UI Principais"
      MainSceneArea_Comp;
      Sidebar_Comp;
      AnnotationDialog_Comp;
      InfoPanel_Comp;
      ThreeScene_Comp;
      SidebarContentLayout_Comp;
    end
\`\`\`
```

## Terminal3DPage

Componente principal da página Terminal 3D (Terminal3DPage).
Orquestra os diversos hooks de gerenciamento de estado da aplicação e renderiza a UI principal.

Returns **JSX.Element** O componente da página Terminal 3D.

## handleFocusAndSelectSystem

Manipula a ação de focar a câmera em um sistema e selecionar todos os equipamentos desse sistema.

### Parameters

*   `systemName` **[string][413]** O nome do sistema para focar e selecionar.

##

Componente de diálogo modal para adicionar ou editar anotações textuais
associadas a um equipamento. Utiliza um Textarea para permitir anotações de texto longo.

```mermaid
  classDiagram
    class AnnotationDialogProps {
      +isOpen: boolean
      +onOpenChange: (isOpen: boolean) -> void
      +onConfirm: (text: string) -> void
      +currentAnnotation: Annotation | null
      +equipmentName: string
    }
    class AnnotationDialog {

    }
    class Annotation {
      +equipmentTag: string
      +text: string
      +createdAt: string
    }
    class ReactFC {

    }
    AnnotationDialog --|> ReactFC
    AnnotationDialogProps ..> Annotation : uses (via currentAnnotation)
    AnnotationDialogProps --> AnnotationDialog : (implicitamente usado por)
```

## AnnotationDialogProps

Props para o componente AnnotationDialog.

### Properties

*   `isOpen` **[boolean][414]** Controla se o diálogo está aberto ou fechado.
*   `currentAnnotation` **([Annotation][34] | null)** A anotação atual sendo editada, ou null se for uma nova anotação.
*   `equipmentName` **[string][413]** O nome do equipamento ao qual a anotação se refere, para exibição no diálogo.

## AnnotationDialog

Renderiza um diálogo modal para o usuário inserir ou editar o texto de uma anotação.
Exibe o nome do equipamento associado e um Textarea para o texto da anotação.
A data de criação/modificação é registrada automaticamente pelo hook `useAnnotationManager`.

### Parameters

*   `props` **[AnnotationDialogProps][7]** As props do componente.

    *   `props.isOpen` &#x20;
    *   `props.onOpenChange` &#x20;
    *   `props.onConfirm` &#x20;
    *   `props.currentAnnotation` &#x20;
    *   `props.equipmentName` &#x20;

Returns **JSX.Element** O componente AnnotationDialog.

## useEffect

Efeito para popular o campo de texto quando o diálogo é aberto ou a anotação atual muda.

## useEffect

### Parameters

*   `props`  Objeto contendo refs para os elementos Three.js que precisam ser redimensionados e uma flag de prontidão.

### Examples

````javascript
// Diagrama de Funcionalidade do useThreeResize:
```mermaid
graph TD
    useThreeResize["useThreeResize (Hook)"]
    Props["UseThreeResizeProps"]
    MountElement["Elemento DOM (mountRef)"]
    ResizeObserver_API["ResizeObserver API"]
    Camera["Câmera (cameraRef)"]
    Renderer["WebGLRenderer (rendererRef)"]
    LabelRenderer["CSS2DRenderer (labelRendererRef)"]
    Composer["EffectComposer (composerRef)"]
    OutlinePass["OutlinePass (outlinePassRef)"]
    ReadyFlag["ready (flag)"]

    Props -- define --> MountElement
    Props -- define --> Camera
    Props -- define --> Renderer
    Props -- define --> LabelRenderer
    Props -- define --> Composer
    Props -- define --> OutlinePass
    Props -- define --> ReadyFlag
    Props --> useThreeResize

    useThreeResize -- verifica --> ReadyFlag
    useThreeResize -- observa --> MountElement
    MountElement -- dispara evento de redimensionamento --> ResizeObserver_API
    ResizeObserver_API -- chama callback --> useThreeResize

    subgraph "Callback de Redimensionamento (handleResize)"
        direction LR
        Callback["handleResize"] -- atualiza --> Camera
        Callback -- atualiza --> Renderer
        Callback -- atualiza --> LabelRenderer
        Callback -- atualiza --> Composer
        Callback -- atualiza --> OutlinePass
    end

    useThreeResize -- executa na montagem e quando 'ready' muda --> Callback

    classDef hook fill:#lightblue,stroke:#333,stroke-width:2px;
    classDef type fill:#lightgoldenrodyellow,stroke:#333,stroke-width:2px;
    classDef obj3d fill:#lightgreen,stroke:#333,stroke-width:2px;
    classDef dom fill:#lightcoral,stroke:#333,stroke-width:2px;
    classDef api fill:#lightsalmon,stroke:#333,stroke-width:2px;
    classDef flag fill:#lightpink,stroke:#333,stroke-width:2px;

    class useThreeResize hook;
    class Props type;
    class Camera,Renderer,LabelRenderer,Composer,OutlinePass obj3d;
    class MountElement dom;
    class ResizeObserver_API api;
    class ReadyFlag flag;
```
````

## handleConfirm

Manipula a confirmação do diálogo, chamando o callback `onConfirm` com o texto atual
e fechando o diálogo.

##

Componente de painel para controles de câmera, especificamente para focar em sistemas.

Principal Responsabilidade:
Renderizar botões para cada sistema disponível, permitindo ao usuário focar a câmera
e selecionar todos os equipamentos pertencentes àquele sistema ao clicar em um botão.

```mermaid
  classDiagram
    class CameraControlsPanelProps {
      +systems: string[]
      +onSetView(systemName: string): void
    }
    class CameraControlsPanel {

    }
    class ReactFC {

    }
    class Button {

    }
    class Card {

    }
    CameraControlsPanel --|> ReactFC
    CameraControlsPanel ..> Button : uses
    CameraControlsPanel ..> Card : uses
```

## CameraControlsPanelProps

Props para o componente CameraControlsPanel.

### Properties

*   `systems` **[Array][415]<[string][413]>** Lista de nomes dos sistemas disponíveis para foco.

## CameraControlsPanel

Renderiza um painel com botões para focar a câmera em sistemas específicos.
Cada botão representa um sistema; ao clicar, a câmera enquadra os equipamentos desse sistema.

### Parameters

*   `props` **[CameraControlsPanelProps][17]** As props do componente.

    *   `props.systems` &#x20;
    *   `props.onSetView` &#x20;

Returns **JSX.Element** O componente CameraControlsPanel.

##

Componente para selecionar o modo de colorização dos equipamentos na cena 3D.

Principal Responsabilidade:
Permitir ao usuário escolher como os equipamentos serão coloridos (por cor base,
estado operacional ou produto) através de um menu dropdown (Select).

```mermaid
  classDiagram
    class ColorModeSelectorProps {
      +colorMode: ColorMode
      +onColorModeChange(mode: ColorMode): void
    }
    class ColorMode {

    }
    ColorModeSelectorProps ..> ColorMode
    class ColorModeSelector {

    }
    class ReactFC {

    }
    class Card {

    }
    class Select {

    }
    class Label {

    }
    ColorModeSelector --|> ReactFC
    ColorModeSelector ..> Card : uses
    ColorModeSelector ..> Select : uses
    ColorModeSelector ..> Label : uses
```

## ColorModeSelectorProps

Props para o componente ColorModeSelector.

### Properties

*   `colorMode` **[ColorMode][402]** O modo de colorização atualmente selecionado.

## ColorModeSelector

Renderiza um Card com um dropdown para selecionar o modo de colorização dos equipamentos.
As opções são "Equipamento (Cor Base)", "Estado Operacional" e "Produto".

### Parameters

*   `props` **[ColorModeSelectorProps][22]** As props do componente.

    *   `props.colorMode` &#x20;
    *   `props.onColorModeChange` &#x20;

Returns **JSX.Element** O componente do seletor de modo de coloração.

##

Componente de painel para exibir controles de histórico de comandos (Undo/Redo).

Principal Responsabilidade:
Renderizar botões que permitem ao usuário desfazer (Undo) e refazer (Redo)
ações previamente executadas na aplicação, com base no estado fornecido pelo
hook `useCommandHistory`.

```mermaid
  classDiagram
    class CommandHistoryPanelProps {
      +canUndo: boolean
      +canRedo: boolean
      +onUndo(): void
      +onRedo(): void
    }
    class CommandHistoryPanel {

    }
    class ReactFC {

    }
    class Button {

    }
    class Card {

    }
    class Undo2Icon {

    }
    class Redo2Icon {

    }
    CommandHistoryPanel --|> ReactFC
    CommandHistoryPanel ..> Button : uses
    CommandHistoryPanel ..> Card : uses
    CommandHistoryPanel ..> Undo2Icon : uses
    CommandHistoryPanel ..> Redo2Icon : uses
```

## CommandHistoryPanelProps

Props para o componente CommandHistoryPanel.

### Properties

*   `canUndo` **[boolean][414]** Indica se a ação de desfazer está disponível.
*   `canRedo` **[boolean][414]** Indica se a ação de refazer está disponível.

## CommandHistoryPanel

Renderiza um painel com botões de Undo e Redo.
A habilitação dos botões é controlada pelas props `canUndo` e `canRedo`.

### Parameters

*   `props` **[CommandHistoryPanelProps][27]** As props do componente.

    *   `props.canUndo` &#x20;
    *   `props.canRedo` &#x20;
    *   `props.onUndo` &#x20;
    *   `props.onRedo` &#x20;

Returns **JSX.Element** O componente CommandHistoryPanel.

##

Componente para exibir o painel de informações detalhadas de um equipamento selecionado.
Renderiza apenas se um único equipamento estiver selecionado na cena 3D.

Responsabilidades:

*   Exibir os atributos do equipamento (nome, TAG, tipo, sistema, área, detalhes).
*   Permitir a alteração do estado operacional do equipamento através de um dropdown.
*   Permitir a alteração do produto associado ao equipamento através de um dropdown.
*   Gerenciar a exibição e interação com anotações:
    *   Exibir o texto e a data da anotação existente.
    *   Fornecer botões para adicionar, editar ou excluir a anotação.
*   Fornecer um botão para fechar o painel de informações (desselecionando o equipamento).

```mermaid
  classDiagram
    class InfoPanelProps {
      +equipment: Equipment | null
      +annotation: Annotation | null
      +onClose: () -> void
      +onOpenAnnotationDialog: () -> void
      +onDeleteAnnotation: (equipmentTag: string) -> void
      +onOperationalStateChange: (equipmentTag: string, newState: string) -> void
      +availableOperationalStatesList: string[]
      +onProductChange: (equipmentTag: string, newProduct: string) -> void
      +availableProductsList: string[]
    }
    class InfoPanel {

    }
    class ReactFC {

    }
    class Equipment {

    }
    class Annotation {

    }
    InfoPanel --|> ReactFC
    InfoPanelProps ..> Equipment : uses
    InfoPanelProps ..> Annotation : uses
```

## InfoPanelProps

Props para o componente InfoPanel.

### equipment

O equipamento selecionado para exibir detalhes. Null se nenhum equipamento único estiver selecionado.

Type: ([Equipment][33] | null)

### annotation

A anotação associada ao equipamento selecionado. Null se não houver anotação.

Type: ([Annotation][34] | null)

### onClose

Callback para fechar o painel de informações (geralmente deseleciona o equipamento).

Type: function (): void

### onOpenAnnotationDialog

Callback para abrir o diálogo de adição/edição de anotação.

Type: function (): void

### onDeleteAnnotation

Callback para excluir a anotação do equipamento especificado.

Type: function (equipmentTag: [string][413]): void

### onOperationalStateChange

Callback para alterar o estado operacional de um equipamento.

Type: function (equipmentTag: [string][413], newState: [string][413]): void

### availableOperationalStatesList

Lista de estados operacionais disponíveis para seleção no dropdown.

Type: [Array][415]<[string][413]>

### onProductChange

Callback para alterar o produto de um equipamento.

Type: function (equipmentTag: [string][413], newProduct: [string][413]): void

### availableProductsList

Lista de produtos disponíveis para seleção no dropdown.

Type: [Array][415]<[string][413]>

## InfoPanel

Renderiza um painel flutuante com informações detalhadas sobre o equipamento selecionado.
Mostra detalhes apenas se um único equipamento estiver selecionado. Permite interações
como alterar estado operacional, produto e gerenciar anotações.

### Parameters

*   `props` **[InfoPanelProps][32]** As props do componente.

    *   `props.equipment` &#x20;
    *   `props.annotation` &#x20;
    *   `props.onClose` &#x20;
    *   `props.onOpenAnnotationDialog` &#x20;
    *   `props.onDeleteAnnotation` &#x20;
    *   `props.onOperationalStateChange` &#x20;
    *   `props.availableOperationalStatesList` &#x20;
    *   `props.onProductChange` &#x20;
    *   `props.availableProductsList` &#x20;

Returns **(JSX.Element | null)** O componente InfoPanel ou null se nenhum equipamento único estiver selecionado.

## handleDeleteClick

Manipula o clique no botão de excluir anotação.

## formattedDate

Formata a data de criação/modificação da anotação para exibição.

Type: ([string][413] | null)

##

Componente para gerenciar a visibilidade das camadas de equipamentos e anotações.

Principal Responsabilidade:
Renderizar um card com checkboxes para cada camada definida, permitindo ao usuário controlar
o que é exibido na cena 3D, como prédios, tanques, anotações, etc.

```mermaid
  classDiagram
    class LayerManagerProps {
      +layers: Layer[]
      +onToggleLayer(layerId: string): void
    }
    class Layer {

    }
    LayerManagerProps ..> Layer
    class LayerManager {

    }
    class ReactFC {

    }
    class Card {

    }
    class Checkbox {

    }
    class Label {

    }
    LayerManager --|> ReactFC
    LayerManager ..> Card : uses
    LayerManager ..> Checkbox : uses
    LayerManager ..> Label : uses
```

## LayerManagerProps

Props para o componente LayerManager.

### Properties

*   `layers` **[Array][415]<[Layer][392]>** A lista de camadas disponíveis e seus estados de visibilidade.

## LayerManager

Renderiza um Card com checkboxes para controlar a visibilidade de cada camada.
Cada checkbox corresponde a uma camada (e.g., Prédios, Tanques, Anotações).

### Parameters

*   `props` **[LayerManagerProps][47]** As props do componente.

    *   `props.layers` &#x20;
    *   `props.onToggleLayer` &#x20;

Returns **JSX.Element** O componente gerenciador de camadas.

##

```mermaid
  classDiagram
    class MainSceneAreaProps {
      +equipment: Equipment[]
      +allEquipmentData: Equipment[]
      +layers: Layer[]
      +annotations: Annotation[]
      +selectedEquipmentTags: string[]
      +onSelectEquipment(tag: string | null, isMultiSelect: boolean): void
      +hoveredEquipmentTag: string | null
      +setHoveredEquipmentTag(tag: string | null): void
      +cameraState: CameraState | undefined
      +onCameraChange(cameraState: CameraState): void
      +initialCameraPosition: Point3D
      +initialCameraLookAt: Point3D
      +colorMode: ColorMode
      +targetSystemToFrame: TargetSystemInfo | null
      +onSystemFramed(): void
      +selectedEquipmentDetails: Equipment | null
      +equipmentAnnotation: Annotation | null
      +onOpenAnnotationDialog(): void
      +onDeleteAnnotation(equipmentTag: string): void
      +onOperationalStateChange(equipmentTag: string, newState: string): void
      +availableOperationalStatesList: string[]
      +onProductChange(equipmentTag: string, newProduct: string): void
      +availableProductsList: string[]
    }
    class Point3D {
      +x: number
      +y: number
      +z: number
    }
    class Equipment {
    }
    class Layer {
    }
    class Annotation {
    }
    class CameraState {
    }
    class ColorMode {
    }
   class TargetSystemInfo {
      +systemName: string
      +viewIndex: number
   }
    MainSceneAreaProps ..> Equipment
    MainSceneAreaProps ..> Layer
    MainSceneAreaProps ..> Annotation
    MainSceneAreaProps ..> CameraState
    MainSceneAreaProps ..> ColorMode
    MainSceneAreaProps ..> Point3D
    MainSceneAreaProps ..> TargetSystemInfo
    class MainSceneArea {
    }
    class ReactFC {
    }
    class ThreeScene {
    }
    class InfoPanel {
    }
    MainSceneArea --|> ReactFC
    MainSceneArea ..> ThreeScene : uses
    MainSceneArea ..> InfoPanel : uses
```

## MainSceneAreaProps

Props para o componente MainSceneArea.
Estas props são, em grande parte, repassadas para `ThreeScene` e `InfoPanel`.

### Properties

*   `equipment` **[Array][415]<[Equipment][33]>** Lista de equipamentos filtrados a serem renderizados na cena.
*   `allEquipmentData` **[Array][415]<[Equipment][33]>** Lista completa de todos os equipamentos, para contexto (e.g., anotações no `ThreeScene`).
*   `layers` **[Array][415]<[Layer][392]>** Configuração das camadas de visibilidade.
*   `annotations` **[Array][415]<[Annotation][34]>** Lista de anotações a serem exibidas.
*   `selectedEquipmentTags` **[Array][415]<[string][413]>** Tags dos equipamentos atualmente selecionados.
*   `hoveredEquipmentTag` **([string][413] | null)** Tag do equipamento atualmente sob o cursor.
*   `cameraState` **([CameraState][394] | [undefined][416])** O estado atual da câmera (posição, lookAt).
*   `colorMode` **[ColorMode][402]** O modo de colorização atual para os equipamentos.
*   `targetSystemToFrame` **([TargetSystemInfo][398] | null)** Informações sobre o sistema e visão a serem enquadrados pela câmera (se houver).
*   `selectedEquipmentDetails` **([Equipment][33] | null)** Detalhes do equipamento único selecionado (para InfoPanel).
*   `equipmentAnnotation` **([Annotation][34] | null)** Anotação do equipamento único selecionado (para InfoPanel).
*   `availableOperationalStatesList` **[Array][415]<[string][413]>** Lista de estados operacionais disponíveis.
*   `availableProductsList` **[Array][415]<[string][413]>** Lista de produtos disponíveis.

## MainSceneArea

Renderiza a área principal da cena 3D e o InfoPanel sobreposto.
Passa todas as props necessárias para os componentes filhos `ThreeScene` e `InfoPanel`.

### Parameters

*   `props` **[MainSceneAreaProps][52]** As props do componente.

    *   `props.equipment` &#x20;
    *   `props.allEquipmentData` &#x20;
    *   `props.layers` &#x20;
    *   `props.annotations` &#x20;
    *   `props.selectedEquipmentTags` &#x20;
    *   `props.onSelectEquipment` &#x20;
    *   `props.hoveredEquipmentTag` &#x20;
    *   `props.setHoveredEquipmentTag` &#x20;
    *   `props.cameraState` &#x20;
    *   `props.onCameraChange` &#x20;
    *   `props.initialCameraPosition` &#x20;
    *   `props.initialCameraLookAt` &#x20;
    *   `props.colorMode` &#x20;
    *   `props.targetSystemToFrame` &#x20;
    *   `props.onSystemFramed` &#x20;
    *   `props.selectedEquipmentDetails` &#x20;
    *   `props.equipmentAnnotation` &#x20;
    *   `props.onOpenAnnotationDialog` &#x20;
    *   `props.onDeleteAnnotation` &#x20;
    *   `props.onOperationalStateChange` &#x20;
    *   `props.availableOperationalStatesList` &#x20;
    *   `props.onProductChange` &#x20;
    *   `props.availableProductsList` &#x20;

Returns **JSX.Element** O componente MainSceneArea.

##

Componente para renderizar o conteúdo principal da sidebar.

Principal Responsabilidade:
Exibir os diversos painéis de controle e filtros dentro da área de conteúdo da sidebar.
Utiliza uma ScrollArea para permitir a rolagem do conteúdo.

Inclui:

*   Controles de câmera ("Focus on System").
*   Filtros de busca textual e seleção por Sistema/Área.
*   Seletor de modo de colorização.
*   Gerenciador de camadas de visibilidade.
*   Link para a documentação externa do projeto.

```mermaid
  classDiagram
    class SidebarContentLayoutProps {
      +searchTerm: string
      +setSearchTerm(value: string): void
      +selectedSistema: string
      +setSelectedSistema(value: string): void
      +availableSistemas: string[]
      +selectedArea: string
      +setSelectedArea(value: string): void
      +availableAreas: string[]
      +colorMode: ColorMode
      +onColorModeChange(mode: ColorMode): void
      +layers: Layer[]
      +onToggleLayer(layerId: string): void
      +cameraViewSystems: string[]
      +onFocusAndSelectSystem(systemName: string): void
    }
    class ColorMode {

    }
    class Layer {

    }
    SidebarContentLayoutProps ..> ColorMode
    SidebarContentLayoutProps ..> Layer
    class SidebarContentLayout {

    }
    class ReactFC {

    }
    class CameraControlsPanel {

    }
    class ColorModeSelector {

    }
    class LayerManager {

    }
    class Input {

    }
    class Select {

    }
    class Button {

    }
    class ScrollArea {

    }
    SidebarContentLayout --|> ReactFC
    SidebarContentLayout ..> CameraControlsPanel : uses
    SidebarContentLayout ..> ColorModeSelector : uses
    SidebarContentLayout ..> LayerManager : uses
    SidebarContentLayout ..> Input : uses
    SidebarContentLayout ..> Select : uses
    SidebarContentLayout ..> Button : uses
    SidebarContentLayout ..> ScrollArea : uses
```

## SidebarContentLayoutProps

Props para o componente SidebarContentLayout.

### Properties

*   `searchTerm` **[string][413]** O termo de busca textual atual.
*   `selectedSistema` **[string][413]** O sistema selecionado para filtro.
*   `availableSistemas` **[Array][415]<[string][413]>** Lista de sistemas disponíveis para filtro.
*   `selectedArea` **[string][413]** A área selecionada para filtro.
*   `availableAreas` **[Array][415]<[string][413]>** Lista de áreas disponíveis para filtro.
*   `colorMode` **[ColorMode][402]** O modo de colorização atual.
*   `layers` **[Array][415]<[Layer][392]>** Lista de camadas para o LayerManager.
*   `cameraViewSystems` **[Array][415]<[string][413]>** Lista de nomes de sistemas para o CameraControlsPanel.

## SidebarContentLayout

Renderiza o layout do conteúdo da sidebar, incluindo filtros, painéis de controle e link para documentação.
Utiliza uma ScrollArea para permitir a rolagem do conteúdo se ele exceder a altura da sidebar.

### Parameters

*   `props` **[SidebarContentLayoutProps][57]** As props do componente.

    *   `props.searchTerm` &#x20;
    *   `props.setSearchTerm` &#x20;
    *   `props.selectedSistema` &#x20;
    *   `props.setSelectedSistema` &#x20;
    *   `props.availableSistemas` &#x20;
    *   `props.selectedArea` &#x20;
    *   `props.setSelectedArea` &#x20;
    *   `props.availableAreas` &#x20;
    *   `props.colorMode` &#x20;
    *   `props.onColorModeChange` &#x20;
    *   `props.layers` &#x20;
    *   `props.onToggleLayer` &#x20;
    *   `props.cameraViewSystems` &#x20;
    *   `props.onFocusAndSelectSystem` &#x20;

Returns **JSX.Element** O componente SidebarContentLayout.

## Terminal

Componente simples para renderizar o cabeçalho do site.

Principal Responsabilidade:
Exibir o título principal da aplicação ("Terminal 3D") e um ícone associado.
Atua como um elemento de branding e navegação de topo fixo.

## SiteHeader

Renderiza o cabeçalho fixo do site.
Exibe o ícone `Terminal` e o nome da aplicação.

Returns **JSX.Element** O componente SiteHeader.

##

*   **See**: [https://github.com/Dicommunitas/ThreeJS\_Terminal\_3D/blob/main/documentation/api/hooks/use-scene-setup/README.md][417] Para a orquestração da configuração da cena.
*   **See**: [https://github.com/Dicommunitas/ThreeJS\_Terminal\_3D/blob/main/documentation/api/hooks/use-equipment-renderer/README.md][418] Para a renderização de equipamentos.
*   **See**: [https://github.com/Dicommunitas/ThreeJS\_Terminal\_3D/blob/main/documentation/api/hooks/use-annotation-pin-renderer/README.md][419] Para a renderização de pins de anotação.
*   **See**: [https://github.com/Dicommunitas/ThreeJS\_Terminal\_3D/blob/main/documentation/api/hooks/use-mouse-interaction/README.md][420] Para interações do mouse.
*   **See**: [https://github.com/Dicommunitas/ThreeJS\_Terminal\_3D/blob/main/documentation/api/hooks/use-scene-outline/README.md][421] Para o efeito de contorno.
*   **See**: [https://github.com/Dicommunitas/ThreeJS\_Terminal\_3D/blob/main/documentation/api/hooks/use-animation-loop/README.md][422] Para o loop de animação.

### Examples

```javascript
// Diagrama de Composição do ThreeScene e seus Hooks:
\`\`\`mermaid
graph TD
    ThreeScene_Comp["ThreeScene (Componente React)"]
    MountPoint["<div ref={mountRef}> (Ponto de Montagem DOM)"]

    ThreeScene_Comp -- renderiza --> MountPoint

    subgraph "Hooks Utilizados por ThreeScene"
        direction LR
        H_SceneSetup["useSceneSetup (Orquestrador de Setup)"]
        H_EquipRenderer["useEquipmentRenderer"]
        H_AnnotPinRenderer["useAnnotationPinRenderer"]
        H_MouseInt["useMouseInteractionManager"]
        H_Outline["useSceneOutline"]
        H_AnimLoop["useAnimationLoop"]
    end

    ThreeScene_Comp -- usa --> H_SceneSetup
    ThreeScene_Comp -- usa --> H_EquipRenderer
    ThreeScene_Comp -- usa --> H_AnnotPinRenderer
    ThreeScene_Comp -- usa --> H_MouseInt
    ThreeScene_Comp -- usa --> H_Outline
    ThreeScene_Comp -- usa --> H_AnimLoop

    H_SceneSetup --> R_Scene["sceneRef"]
    H_SceneSetup --> R_Camera["cameraRef"]
    H_SceneSetup --> R_Renderer["rendererRef"]
    H_SceneSetup --> R_LabelRenderer["labelRendererRef"]
    H_SceneSetup --> R_Controls["controlsRef"]
    H_SceneSetup --> R_Composer["composerRef"]
    H_SceneSetup --> R_OutlinePass["outlinePassRef"]
    H_SceneSetup --> F_IsSceneReady["isSceneReady (flag)"]
    H_SceneSetup --> F_IsControlsReady["isControlsReady (flag)"]

    H_EquipRenderer -- usa --> R_Scene
    H_AnnotPinRenderer -- usa --> R_Scene
    H_AnnotPinRenderer -- usa --> R_LabelRenderer
    H_MouseInt -- usa --> MountPoint
    H_MouseInt -- usa --> R_Camera
    H_Outline -- usa --> R_OutlinePass
    H_AnimLoop -- usa --> R_Scene
    H_AnimLoop -- usa --> R_Camera
    H_AnimLoop -- usa --> R_Controls
    H_AnimLoop -- usa --> R_Composer
    H_AnimLoop -- usa --> R_LabelRenderer

    classDef comp fill:#lightcoral,stroke:#333,stroke-width:2px;
    classDef hook fill:#lightblue,stroke:#333,stroke-width:2px;
    classDef ref fill:#lightgoldenrodyellow,stroke:#333,stroke-width:2px;
    classDef flag fill:#lightpink,stroke:#333,stroke-width:2px;

    class ThreeScene_Comp comp;
    class MountPoint comp;
    class H_SceneSetup,H_EquipRenderer,H_AnnotPinRenderer,H_MouseInt,H_Outline,H_AnimLoop hook;
    class R_Scene,R_Camera,R_Renderer,R_LabelRenderer,R_Controls,R_Composer,R_OutlinePass ref;
    class F_IsSceneReady,F_IsControlsReady flag;
\`\`\`
```

## ThreeSceneProps

Props para o componente ThreeScene.

### Properties

*   `equipment` **[Array][415]<[Equipment][33]>** Lista de equipamentos filtrados a serem renderizados na cena.
*   `allEquipmentData` **[Array][415]<[Equipment][33]>** Lista completa de todos os equipamentos, para contexto (e.g., anotações).
*   `layers` **[Array][415]<[Layer][392]>** Configuração das camadas de visibilidade.
*   `annotations` **[Array][415]<[Annotation][34]>** Lista de anotações a serem exibidas.
*   `selectedEquipmentTags` **([Array][415]<[string][413]> | [undefined][416])** Tags dos equipamentos atualmente selecionados.
*   `hoveredEquipmentTag` **([string][413] | null | [undefined][416])** Tag do equipamento atualmente sob o cursor.
*   `cameraState` **([CameraState][394] | [undefined][416])** O estado atual da câmera (posição, lookAt) gerenciado externamente. Pode ser indefinido durante a inicialização.
*   `colorMode` **[ColorMode][402]** O modo de colorização atual para os equipamentos.
*   `targetSystemToFrame` **([TargetSystemInfo][398] | null)** O sistema que deve ser enquadrado pela câmera (se houver), incluindo o índice da visão.

## ThreeScene

Componente React principal para renderizar e interagir com a cena 3D usando Three.js.
Atua como um orquestrador de hooks especializados que gerenciam diferentes aspectos da cena.

Type: React.FC<[ThreeSceneProps][65]>

### Parameters

*   `props` **[ThreeSceneProps][65]** As props do componente.

Returns **JSX.Element** O elemento div que serve como contêiner para a cena 3D.

## THEMES

Define os seletores CSS para os temas claro e escuro.
Usado internamente pelo ChartStyle para aplicar cores específicas do tema.

## ChartConfig

Configuração para os gráficos, permitindo a definição de rótulos, ícones e cores
para cada item de dados do gráfico. As cores podem ser definidas diretamente ou
através de um objeto de tema para suportar diferentes temas (claro/escuro).

Type: any

### Examples

````javascript
```ts
const chartConfig = {
  visitors: {
    label: "Visitantes",
    color: "hsl(var(--chart-1))",
  },
  chrome: {
    label: "Chrome",
    color: "hsl(var(--chart-2))",
    icon: ChromeIcon, // Exemplo de ícone
  },
  safari: {
    label: "Safari",
    theme: { // Exemplo de cores baseadas em tema
      light: "hsl(var(--chart-3))",
      dark: "hsl(var(--chart-5))",
    }
  },
} satisfies ChartConfig;
```
````

## Form

Componente provedor que propaga os métodos `useForm` para todos os componentes filhos
através da API de Contexto do React. Para ser usado com \`useFormContext\`.

### Parameters

*   `props` **FormProviderProps\<TFieldValues, TContext, TTransformedValues>** Todos os métodos de `useForm`.

### Examples

```javascript
* \`\`\`tsx
function App() {
  const methods = useForm();
  const onSubmit = data => console.log(data);

  return (
    <FormProvider {...methods} >
      <form onSubmit={methods.handleSubmit(onSubmit)}>
        <NestedInput />
        <input type="submit" />
      </form>
    </FormProvider>
  );
}

 function NestedInput() {
  const { register } = useFormContext(); // retrieve all hook methods
  return <input {...register("test")} />;
}
* \`\`\`
```

Returns **JSX.Element**&#x20;

##

Componente de Sidebar reutilizável e altamente configurável.

Principal Responsabilidade:
Fornecer uma estrutura de sidebar flexível que pode ser usada de várias maneiras:

*   Como uma sidebar tradicional fixa ou flutuante.
*   Em modo "icon" (colapsada, mostrando apenas ícones).
*   Como um "offcanvas" (desliza para fora da tela).
*   Adaptável para dispositivos móveis (geralmente usando o modo offcanvas).

Subcomponentes:

*   `SidebarProvider`: Contexto para gerenciar o estado da sidebar (aberta/fechada, modo).
*   `Sidebar`: O contêiner principal da sidebar.
*   `SidebarTrigger`: Botão para alternar o estado da sidebar.
*   `SidebarRail`: Barra lateral fina para alternar a sidebar quando colapsada.
*   `SidebarInset`: Contêiner para o conteúdo principal da página, que se ajusta à sidebar.
*   `SidebarHeader`, `SidebarFooter`, `SidebarContent`: Seções estruturais dentro da sidebar.
*   `SidebarGroup`, `SidebarGroupLabel`, `SidebarGroupAction`, `SidebarGroupContent`: Para agrupar itens.
*   `SidebarMenu`, `SidebarMenuItem`, `SidebarMenuButton`, `SidebarMenuAction`, `SidebarMenuBadge`, `SidebarMenuSkeleton`, `SidebarMenuSub`, `SidebarMenuSubItem`, `SidebarMenuSubButton`: Para criar menus de navegação dentro da sidebar.
*   `SidebarInput`, `SidebarSeparator`: Elementos de UI utilitários para a sidebar.

Utiliza cookies para persistir o estado da sidebar entre as sessões (desktop) e atalhos de teclado.

```mermaid
graph LR
  App --> SidebarProvider_Context["SidebarProvider (Context)"]
  SidebarProvider_Context --> Sidebar_Comp["Sidebar"]
  SidebarProvider_Context --> SidebarInset_Comp["SidebarInset (Main Content Wrapper)"]
  App --> SidebarTrigger_Button["SidebarTrigger (Button)"]

  Sidebar_Comp --> SidebarHeader_Sec["SidebarHeader"]
  Sidebar_Comp --> SidebarContent_Sec["SidebarContent (Scrollable)"]
  Sidebar_Comp --> SidebarFooter_Sec["SidebarFooter"]

  SidebarContent_Sec --> SidebarGroup_Container["SidebarGroup"]
  SidebarGroup_Container --> SidebarGroupLabel_Text["SidebarGroupLabel"]
  SidebarGroup_Container --> SidebarMenu_List["SidebarMenu (ul)"]

  SidebarMenu_List --> SidebarMenuItem_Item["SidebarMenuItem (li)"]
  SidebarMenuItem_Item --> SidebarMenuButton_Action["SidebarMenuButton (Button/Link)"]
  SidebarMenuItem_Item --> SidebarMenuAction_Opt["SidebarMenuAction (Optional Button)"]
  SidebarMenuItem_Item --> SidebarMenuBadge_Info["SidebarMenuBadge (Optional Info)"]

  SidebarMenuButton_Action --> SidebarMenuSub_SubList["SidebarMenuSub (ul for dropdowns)"]
  SidebarMenuSub_SubList --> SidebarMenuSubItem_SubItem["SidebarMenuSubItem (li)"]
  SidebarMenuSubItem_SubItem --> SidebarMenuSubButton_SubAction["SidebarMenuSubButton (Button/Link)"]
```

## useSidebar

Hook para acessar o contexto da Sidebar.
Deve ser usado dentro de um `SidebarProvider`.

*   Throws **[Error][423]** Se usado fora de um `SidebarProvider`.

Returns **SidebarContext** O contexto da sidebar.

## SidebarProvider

Provedor de contexto para o estado da sidebar.
Gerencia se a sidebar está aberta/fechada, tanto no desktop quanto no mobile,
e o estado colapsado/expandido.

### defaultOpen

Estado de abertura padrão da sidebar no desktop. Padrão: `true`.

Type: [boolean][414]

### open

Controla o estado de abertura da sidebar no desktop externamente.

Type: [boolean][414]

### onOpenChange

Callback para quando o estado de abertura da sidebar no desktop muda.

Type: function (open: [boolean][414]): void

## Sidebar

Componente principal da Sidebar.
Renderiza a sidebar com base no estado do `SidebarProvider` e nas props de configuração.

### side

Lado em que a sidebar aparecerá. Padrão: `"left"`.

Type: (`"left"` | `"right"`)

### variant

Variante visual da sidebar. Padrão: `"sidebar"`.

*   `"sidebar"`: Sidebar tradicional.
*   `"floating"`: Sidebar flutuante com sombra e bordas.
*   `"inset"`: Sidebar que se encaixa dentro de um layout principal (`SidebarInset`).

Type: (`"sidebar"` | `"floating"` | `"inset"`)

### collapsible

Comportamento de colapso da sidebar. Padrão: `"offcanvas"`.

*   `"offcanvas"`: A sidebar desliza para fora da tela quando colapsada.
*   `"icon"`: A sidebar encolhe para mostrar apenas ícones quando colapsada.
*   `"none"`: A sidebar não é colapsável.

Type: (`"offcanvas"` | `"icon"` | `"none"`)

## SidebarTrigger

Botão para alternar o estado de visibilidade da sidebar.
Em modo mobile, abre/fecha a sidebar offcanvas.
Em modo desktop, colapsa/expande a sidebar.

## SidebarRail

Barra lateral fina ("rail") que aparece quando a sidebar está colapsada em modo "icon".
Permite ao usuário clicar para expandir a sidebar.

## SidebarInset

Componente para envolver o conteúdo principal da página.
Ajusta sua margem e aparência com base no estado e variante da sidebar,
especialmente útil com a variante "inset".

## SidebarInput

Componente de Input estilizado para uso dentro da Sidebar.

## SidebarHeader

Contêiner para o cabeçalho da Sidebar.

## SidebarFooter

Contêiner para o rodapé da Sidebar.

## SidebarSeparator

Componente Separator estilizado para uso dentro da Sidebar.

## SidebarContent

Contêiner para a área de conteúdo principal da Sidebar (geralmente rolável).

## SidebarGroup

Contêiner para agrupar logicamente itens dentro da Sidebar.

## SidebarGroupLabel

Rótulo para um `SidebarGroup`. Fica oculto quando a sidebar está em modo "icon".

## SidebarGroupAction

Botão de ação opcional para um `SidebarGroup` (e.g., um botão "+").
Fica oculto quando a sidebar está em modo "icon".

## SidebarGroupContent

Contêiner para o conteúdo de um `SidebarGroup`.

## SidebarMenu

Lista `<ul>` para um menu dentro da Sidebar.

## SidebarMenuItem

Item `<li>` de um `SidebarMenu`.

## SidebarMenuButton

Botão clicável dentro de um `SidebarMenuItem`.
Pode conter um ícone e texto. O texto é truncado quando a sidebar está em modo "icon".
Suporta um tooltip opcional que aparece quando a sidebar está em modo "icon".

### isActive

Indica se o item de menu está ativo.

Type: [boolean][414]

### tooltip

Conteúdo do tooltip a ser exibido no modo "icon", ou um objeto de props para `TooltipContent`.

Type: ([string][413] | React.ComponentProps\<any>)

## SidebarMenuAction

Botão de ação opcional para um `SidebarMenuItem` (e.g., um ícone de "mais opções").
Fica oculto quando a sidebar está em modo "icon".
Pode ser configurado para aparecer apenas no hover.

### showOnHover

Se true, a ação só aparece quando o mouse está sobre o item de menu.

Type: [boolean][414]

## SidebarMenuBadge

Badge opcional para um `SidebarMenuItem` (e.g., para contagens de notificações).
Fica oculto quando a sidebar está em modo "icon".

## SidebarMenuSkeleton

Componente de esqueleto de carregamento para itens de menu.
Útil para indicar que o conteúdo do menu está sendo carregado.

### showIcon

Se true, mostra um esqueleto de ícone.

Type: [boolean][414]

## SidebarMenuSub

Lista `<ul>` para um submenu dentro de um `SidebarMenuButton` (geralmente usado com dropdowns ou accordions).
Fica oculto quando a sidebar está em modo "icon".

## SidebarMenuSubItem

Item `<li>` de um `SidebarMenuSub`.

## SidebarMenuSubButton

Botão clicável (ou link) dentro de um `SidebarMenuSubItem`.

### size

Tamanho do botão do submenu.

Type: (`"sm"` | `"md"`)

### isActive

Indica se o item de submenu está ativo.

Type: [boolean][414]

## Equipment

Fornece os dados iniciais para equipamentos e camadas da aplicação.
Estes dados são usados para popular o estado inicial da aplicação quando ela é carregada.
Define a estrutura de cada equipamento e as camadas de visibilidade padrão.

Exporta:

*   `initialEquipment`: Array de objetos `Equipment` representando os itens 3D na cena.
*   `initialLayers`: Array de objetos `Layer` especificando as camadas de visibilidade.
*   `initialAnnotations`: Array inicial de `Annotation` (geralmente vazio para começar).

## Equipment

Utilitário para filtrar a lista de equipamentos com base em múltiplos critérios.

Principal Responsabilidade:
Aplicar filtros de Sistema, Área e um termo de busca textual (nome, tipo, tag)
a uma lista de equipamentos, retornando a lista filtrada.

```mermaid
  classDiagram
    class EquipmentFilterCriteria {
      +searchTerm: string
      +selectedSistema: string
      +selectedArea: string
    }
    class getFilteredEquipment {

    }
    class Equipment {

    }
    getFilteredEquipment --|> EquipmentFilterCriteria : uses as criteria
    getFilteredEquipment --|> Equipment : returns array of
    
```

Exporta:

*   `EquipmentFilterCriteria`: Interface para os critérios de filtro.
*   `getFilteredEquipment`: Função principal para filtrar equipamentos.

## Equipment

*   **See**: [https://github.com/Dicommunitas/ThreeJS\_Terminal\_3D/blob/main/documentation/api/core/data/initial-data/README.md][424] Para os dados iniciais de equipamentos e camadas.
*   **See**: [https://github.com/Dicommunitas/ThreeJS\_Terminal\_3D/blob/main/documentation/api/lib/types/README.md#Equipment][425] Para a interface de Equipamento.
*   **See**: [https://github.com/Dicommunitas/ThreeJS\_Terminal\_3D/blob/main/documentation/api/lib/types/README.md#Annotation][426] Para a interface de Anotação.

### Examples

```javascript
// Diagrama de Estrutura do Repositório em Memória:
\`\`\`mermaid
classDiagram
    class RepositorioMemoria {
        -equipmentStore: Map_string_Equipment_
        -annotationStore: Map_string_Annotation_
        -isInitialized: boolean
        +initializeRepository() void
    }
    class RepositorioEquipamentos {
        +getEquipmentByTag(tag: string): Equipment | undefined
        +getAllEquipment(): Equipment[]
        +addEquipment(equipment: Equipment): Equipment
        +updateEquipment(tag: string, updates: Partial_Equipment_): Equipment | undefined
        +deleteEquipment(tag: string): boolean
        +_resetAndLoadInitialData(): void
    }
    class RepositorioAnotacoes {
        +getAnnotationByEquipmentTag(equipmentTag: string): Annotation | undefined
        +getAllAnnotations(): Annotation[]
        +addOrUpdateAnnotation(annotation: Annotation): Annotation
        +deleteAnnotation(equipmentTag: string): boolean
        +initializeAnnotations(annotations: Annotation[]): void
    }
    class DadosIniciais {
        +initialEquipment: Equipment[]
        +initialAnnotations: Annotation[]
    }

    RepositorioMemoria --|> DadosIniciais : carrega dados de
    RepositorioMemoria o-- RepositorioEquipamentos : expõe
    RepositorioMemoria o-- RepositorioAnotacoes : expõe

    note for RepositorioMemoria "Módulo auto-inicializável."
    note for RepositorioEquipamentos "Gerencia o CRUD de Equipamentos."
    note for RepositorioAnotacoes "Gerencia o CRUD de Anotações."
\`\`\`
```

## Equipment

Define as principais interfaces de tipo usadas em toda a aplicação Terminal 3D.
Estas estruturas de dados são cruciais para a consistência e tipagem do projeto,
descrevendo entidades como Equipamentos, Camadas, Estado da Câmera, Comandos e Anotações.
A clareza e precisão destas interfaces facilitam o desenvolvimento, a manutenção e
a compreensão do fluxo de dados através dos componentes e hooks.

## Equipment

Representa um equipamento na cena 3D. Contém todas as propriedades
necessárias para sua renderização, identificação e manipulação de estado.

### Properties

*   `tag` **[string][413]** Identificador único e imutável do equipamento (e.g., "bldg-01", "tank-alpha"). Usado como chave.
*   `name` **[string][413]** Nome legível do equipamento para exibição na UI (e.g., "Main Office", "Storage Tank Alpha").
*   `type` **(`"Building"` | `"Crane"` | `"Tank"` | `"Terrain"` | `"Pipe"` | `"Valve"`)** Categoria do equipamento, influencia sua geometria e interações.
    'Terrain' é um tipo especial para o plano de chão.
*   `sistema` **[string][413]?** O sistema operacional ou funcional ao qual o equipamento pertence (e.g., "GA", "ODB"). Opcional.
*   `area` **[string][413]?** A área física ou lógica onde o equipamento está localizado (e.g., "Área 31", "Área de Processo"). Opcional.
*   `operationalState` **[string][413]?** Estado operacional atual do equipamento (e.g., 'operando', 'manutenção', 'em falha', 'não operando', 'Não aplicável').
    Usado para colorização e informação. Opcional.
*   `product` **[string][413]?** Produto atualmente associado ou processado pelo equipamento (e.g., "70H", "660", "Não aplicável").
    Usado para colorização e informação. Opcional.
*   `radius` **[number][427]?** Raio para equipamentos com geometria cilíndrica (e.g., 'Tank', 'Pipe') ou esférica (e.g., 'Valve'). Opcional se `size` for usado.
*   `height` **[number][427]?** Altura para equipamentos com geometria cilíndrica (e.g., 'Tank', 'Crane'). Para 'Pipe', representa o comprimento. Opcional se `size` for usado.
*   `color` **[string][413]** Cor base do equipamento em formato hexadecimal (e.g., '#78909C'). Usada no modo de colorização 'Equipamento'.
*   `details` **[string][413]?** Detalhes textuais adicionais sobre o equipamento. Exibido no `InfoPanel`. Opcional.

## initialEquipment

Lista inicial de equipamentos para a cena 3D.
Cada equipamento possui propriedades como tag, nome, tipo, sistema, área, estado operacional,
produto, posição, dimensões (ou raio/altura), cor, detalhes e categoria.

Type: [Array][415]<[Equipment][33]>

## initialLayers

Lista inicial de camadas para controle de visibilidade na interface.
Cada camada define um nome, o tipo de equipamento que ela controla (ou 'Annotations' para pins de anotação, 'Terrain' para o chão),
e seu estado de visibilidade inicial.

Type: [Array][415]<[Layer][392]>

## initialAnnotations

Lista inicial de anotações. Geralmente vazia para começar,
a menos que queira popular com dados de exemplo.

Type: [Array][415]<[Annotation][34]>

## THREE

## THREE

### Examples

````javascript
// Diagrama de Funcionalidade do calculateViewForMeshes:
```mermaid
  classDiagram
    class calculateViewForMeshes_params {
      +meshes: THREE.Object3D[]
      +camera: THREE.PerspectiveCamera
    }
    class calculateViewForMeshes_return {
      +default: SystemView
      +topDown: SystemView
      +isometric: SystemView
    }
    class SystemView {
      +position: Point3D
      +lookAt: Point3D
    }
    class calculateViewForMeshes {
    }
    calculateViewForMeshes ..> calculateViewForMeshes_params : receives
    calculateViewForMeshes ..> calculateViewForMeshes_return : returns or null
```
````

## THREE

Fábrica para criar geometrias de equipamentos para a cena Three.js.

Principal Responsabilidade:
Encapsular a lógica de criação de diferentes tipos de `THREE.BufferGeometry`
com base no tipo de equipamento (`item.type`) e suas dimensões (`item.size`, `item.radius`, `item.height`).
Isso promove o Single Responsibility Principle, isolando a lógica de criação
de geometrias do componente `ThreeScene` ou outras partes do sistema.
Fornece uma geometria padrão (BoxGeometry) caso um tipo de equipamento desconhecido seja fornecido.

Exporta:

*   `createGeometryForItem`: Função para criar a geometria apropriada para um equipamento.

## THREE

### Examples

````javascript
// Diagrama de Interação para `updateAnnotationPins`:
```mermaid
  classDiagram
    class UpdateAnnotationPinsParams {
      +scene: THREE.Scene | null
      +labelRenderer: CSS2DRenderer | null
      +annotations: Annotation[]
      +equipmentData: Equipment[]
      +layers: Layer[]
      +existingPinsRef: React.MutableRefObject_CSS2DObject_Array_
    }
    class Annotation {
       +equipmentTag: string
       +text: string
       +createdAt: string
    }
    class Equipment {
       +tag: string
       +position: object
       +size: object
       +height: number
       +radius: number
       +type: string
    }
    class Layer {
       +id: string
       +isVisible: boolean
    }
    class ReactMutableRefObject_CSS2DObject_Array_ {
      current: CSS2DObject[]
    }
    UpdateAnnotationPinsParams ..> Annotation
    UpdateAnnotationPinsParams ..> Equipment
    UpdateAnnotationPinsParams ..> Layer
    UpdateAnnotationPinsParams ..> ReactMutableRefObject_CSS2DObject_Array_
    class updateAnnotationPins {

    }
    updateAnnotationPins ..> UpdateAnnotationPinsParams : receives
```

Exporta:
- `updateLabelRendererSize`: Atualiza o tamanho do CSS2DRenderer.
- `updateAnnotationPins`: Gerencia os pins de anotação na cena.
````

## THREE

### Examples

````javascript
// Diagrama de Retorno da Função `setupPostProcessing`:
```mermaid
  classDiagram
    class setupPostProcessing_return {
      +composer: EffectComposer
      +outlinePass: OutlinePass
    }
    class setupPostProcessing {

    }
    setupPostProcessing ..> setupPostProcessing_return : returns
```

Exporta:
- `setupPostProcessing`: Configura o pipeline inicial de pós-processamento.
- `updatePostProcessingSize`: Atualiza o tamanho do composer e do outline pass.
- `updateOutlineEffect`: Atualiza quais objetos são contornados e com qual estilo.
````

## THREE

### Examples

````javascript
// Diagrama de Estrutura e Interdependências:
```mermaid
  graph TD;
    A[setupRenderPipeline] --> B{renderer: WebGLRenderer};
    A --> C{labelRenderer: CSS2DRenderer};
    A --> D{composer: EffectComposer};
    A --> E{outlinePass: OutlinePass};

    F[UpdateEquipmentMeshesParams] --> G[updateEquipmentMeshesInScene];
    class H[Equipment] --> F;
    class I[Layer] --> F;
    class J[ColorMode] --> F;

    classDef params fill:#DCDCDC,stroke:#333,stroke-width:2px,color:black;
    classDef func fill:#ADD8E6,stroke:#333,stroke-width:2px,color:black;
    classDef return fill:#90EE90,stroke:#333,stroke-width:2px,color:black;
    classDef type fill:#FFFFE0,stroke:#333,stroke-width:2px,color:black;

    class A func;
    class B,C,D,E return;
    class F params;
    class G func;
    class H,I,J type;
```

Exporta:
- `setupLighting`: Configura a iluminação da cena.
- `setupGroundPlane`: Configura o plano de chão.
- `setupRenderPipeline`: Inicializa os renderizadores e o pipeline de pós-processamento.
- `updateEquipmentMeshesInScene`: Atualiza dinamicamente os meshes dos equipamentos.
````

## THREE

### Parameters

*   `props`  Propriedades para configurar o loop de animação.

### Examples

````javascript
// Diagrama de Fluxo do useAnimationLoop:
```mermaid
sequenceDiagram
    participant ComponentePai as Comp. (ex: ThreeScene)
    participant useAnimationLoop as Hook
    participant Navegador
    participant OrbitControls
    participant EffectComposer
    participant CSS2DRenderer

    ComponentePai ->>+ useAnimationLoop: Chama com refs e isSceneReady=true
    useAnimationLoop ->> Navegador: requestAnimationFrame(animate)
    Navegador -->> useAnimationLoop: Chama animate()
    loop Cada Quadro
        useAnimationLoop ->> OrbitControls: controls.update() (se habilitado)
        useAnimationLoop ->> ComponentePai: onFrameUpdate() (callback opcional)
        useAnimationLoop ->> EffectComposer: composer.render()
        useAnimationLoop ->> CSS2DRenderer: labelRenderer.render()
        useAnimationLoop ->> Navegador: requestAnimationFrame(animate)
    end
    Note right of ComponentePai: Quando desmontado ou isSceneReady=false
    useAnimationLoop ->> Navegador: cancelAnimationFrame()
```
````

## THREE

*   **See**: [https://github.com/Dicommunitas/ThreeJS\_Terminal\_3D/blob/main/documentation/api/hooks/useThreeCore/README.md][428] Para inicialização da cena e câmera.
*   **See**: [https://github.com/Dicommunitas/ThreeJS\_Terminal\_3D/blob/main/documentation/api/hooks/useThreeRenderers/README.md][429] Para configuração dos renderizadores e pós-processamento.
*   **See**: [https://github.com/Dicommunitas/ThreeJS\_Terminal\_3D/blob/main/documentation/api/hooks/useThreeOrbitControls/README.md][430] Para configuração dos controles de órbita.
*   **See**: [https://github.com/Dicommunitas/ThreeJS\_Terminal\_3D/blob/main/documentation/api/hooks/useThreeSceneElements/README.md][431] Para configuração de iluminação e plano de chão.
*   **See**: [https://github.com/Dicommunitas/ThreeJS\_Terminal\_3D/blob/main/documentation/api/hooks/useThreeResize/README.md][432] Para manipulação de redimensionamento.

### Examples

```javascript
// Diagrama de Composição do useSceneSetup:
\`\`\`mermaid
graph TD
    useSceneSetup_Orchestrator["useSceneSetup (Orquestrador)"]

    subgraph "Hooks Especializados de Setup"
        direction LR
        H_Core["useThreeCore"]
        H_Renderers["useThreeRenderers"]
        H_Controls["useThreeOrbitControls"]
        H_Elements["useThreeSceneElements"]
        H_Resize["useThreeResize"]
    end

    useSceneSetup_Orchestrator -- compõe --> H_Core
    useSceneSetup_Orchestrator -- compõe --> H_Renderers
    useSceneSetup_Orchestrator -- compõe --> H_Controls
    useSceneSetup_Orchestrator -- compõe --> H_Elements
    useSceneSetup_Orchestrator -- compõe --> H_Resize

    H_Core --> R_Scene["sceneRef"]
    H_Core --> R_Camera["cameraRef"]

    H_Renderers -- usa --> R_Scene
    H_Renderers -- usa --> R_Camera
    H_Renderers --> R_Renderer["rendererRef"]
    H_Renderers --> R_LabelRenderer["labelRendererRef"]
    H_Renderers --> R_Composer["composerRef"]
    H_Renderers --> R_OutlinePass["outlinePassRef"]
    H_Renderers --> F_RenderersReady["areRenderersReady (flag)"]

    H_Controls -- usa --> R_Camera
    H_Controls -- usa --> R_Renderer
    H_Controls --> R_OrbitControls["controlsRef"]
    H_Controls --> F_ControlsReady["isControlsReady (flag)"]

    H_Elements -- usa --> R_Scene
    H_Elements --> R_GroundMesh["groundMeshRef"]

    H_Resize -- usa --> R_Camera
    H_Resize -- usa --> R_Renderer
    H_Resize -- usa --> R_LabelRenderer
    H_Resize -- usa --> R_Composer
    H_Resize -- usa --> R_OutlinePass

    useSceneSetup_Orchestrator -- retorna --> R_Scene
    useSceneSetup_Orchestrator -- retorna --> R_Camera
    useSceneSetup_Orchestrator -- retorna --> R_Renderer
    useSceneSetup_Orchestrator -- retorna --> R_LabelRenderer
    useSceneSetup_Orchestrator -- retorna --> R_OrbitControls
    useSceneSetup_Orchestrator -- retorna --> R_Composer
    useSceneSetup_Orchestrator -- retorna --> R_OutlinePass
    useSceneSetup_Orchestrator -- retorna --> R_GroundMesh
    useSceneSetup_Orchestrator -- retorna --> F_SceneReady["isSceneReady (flag combinada)"]
    useSceneSetup_Orchestrator -- retorna --> F_ControlsReady

    classDef hook fill:#lightblue,stroke:#333,stroke-width:2px;
    classDef ref fill:#lightgoldenrodyellow,stroke:#333,stroke-width:2px;
    classDef flag fill:#lightpink,stroke:#333,stroke-width:2px;

    class useSceneSetup_Orchestrator hook;
    class H_Core,H_Renderers,H_Controls,H_Elements,H_Resize hook;
    class R_Scene,R_Camera,R_Renderer,R_LabelRenderer,R_OrbitControls,R_Composer,R_OutlinePass,R_GroundMesh ref;
    class F_RenderersReady,F_ControlsReady,F_SceneReady flag;
\`\`\`
```

## getCharNumericValue

Converte um caractere ('0'-'9' ou 'A'-'Z') para um valor numérico (0-35).
'0'-'9' mapeiam para 0-9.
'A'-'Z' (case-insensitive) mapeiam para 10-35.
Caracteres inválidos retornam 0.
Esta função é usada para gerar componentes de cor (R, G, B) a partir de códigos de produto.

### Parameters

*   `char` **[string][413]** O caractere a ser convertido.

Returns **[number][427]** O valor numérico correspondente (0-35), ou 0 para caracteres inválidos.

## getEquipmentColor

Determina a cor final de um equipamento com base no modo de colorização e seus atributos.

### Parameters

*   `item` **[Equipment][33]** O equipamento para o qual a cor será determinada.
*   `colorMode` **[ColorMode][402]** O modo de colorização selecionado ('Equipamento', 'Estado Operacional', 'Produto').

Returns **THREE.Color** A cor calculada para o equipamento, como uma instância de `THREE.Color`.

## EquipmentFilterCriteria

Define os critérios de filtro aplicáveis aos equipamentos.

### Properties

*   `searchTerm` **[string][413]** Termo de busca textual. Múltiplos termos separados por espaço são tratados com lógica "E".
*   `selectedSistema` **[string][413]** Sistema selecionado para filtro (ou "All" para não filtrar por sistema).
*   `selectedArea` **[string][413]** Área selecionada para filtro (ou "All" para não filtrar por área).

## getFilteredEquipment

Filtra uma lista de equipamentos com base nos critérios fornecidos.
A filtragem ocorre na seguinte ordem: Sistema, depois Área, depois Termo de Busca.
A filtragem textual por `searchTerm` considera nome, tipo e tag, com lógica "E" para múltiplos termos.
Os filtros de sistema e área são aplicados se não forem "All".

### Parameters

*   `allEquipment` **[Array][415]<[Equipment][33]>** A lista completa de equipamentos a serem filtrados.
*   `criteria` **[EquipmentFilterCriteria][141]** Os critérios de filtro a serem aplicados.

Returns **[Array][415]<[Equipment][33]>** A lista de equipamentos filtrada.

## equipmentRepository

Objeto repositório para gerenciar dados de `Equipment`.

### getEquipmentByTag

Obtém um equipamento pela sua tag.

#### Parameters

*   `tag` **[string][413]** A tag do equipamento.

Returns **([Equipment][33] | [undefined][416])** O objeto do equipamento (uma cópia), ou undefined se não encontrado.

### getAllEquipment

Obtém todos os equipamentos.

Returns **[Array][415]<[Equipment][33]>** Um array com todos os equipamentos (cópias).

### addEquipment

Adiciona um novo equipamento. Se um equipamento com a mesma tag já existir,
ele será atualizado em vez de adicionar um novo.

#### Parameters

*   `equipment` **[Equipment][33]** O objeto do equipamento a ser adicionado.

Returns **[Equipment][33]** O equipamento adicionado (ou atualizado, uma cópia).

### updateEquipment

Atualiza um equipamento existente.

#### Parameters

*   `tag` **[string][413]** A tag do equipamento a ser atualizado.
*   `updates` **Partial<[Equipment][33]>** Um objeto com as propriedades do equipamento a serem atualizadas.
    A propriedade `tag` não pode ser alterada por este método.

Returns **([Equipment][33] | [undefined][416])** O equipamento atualizado (uma cópia), ou undefined se não encontrado.

### deleteEquipment

Exclui um equipamento pela sua tag.

#### Parameters

*   `tag` **[string][413]** A tag do equipamento a ser excluído.

Returns **[boolean][414]** True se o equipamento foi excluído com sucesso, false caso contrário.

## annotationRepository

Objeto repositório para gerenciar dados de `Annotation`.

### getAnnotationByEquipmentTag

Obtém uma anotação pela tag do equipamento associado.

#### Parameters

*   `equipmentTag` **[string][413]** A tag do equipamento.

Returns **([Annotation][34] | [undefined][416])** A anotação (uma cópia), ou undefined se não encontrada.

### getAllAnnotations

Obtém todas as anotações.

Returns **[Array][415]<[Annotation][34]>** Um array com todas as anotações (cópias).

### addOrUpdateAnnotation

Adiciona uma nova anotação ou atualiza uma existente se já houver uma para a mesma `equipmentTag`.

#### Parameters

*   `annotation` **[Annotation][34]** O objeto da anotação a ser adicionado/atualizado.

Returns **[Annotation][34]** A anotação adicionada/atualizada (uma cópia).

### deleteAnnotation

Exclui uma anotação pela tag do equipamento associado.

#### Parameters

*   `equipmentTag` **[string][413]** A tag do equipamento cuja anotação será excluída.

Returns **[boolean][414]** True se a anotação foi excluída com sucesso, false caso contrário.

### initializeAnnotations

Inicializa explicitamente as anotações no repositório.
Limpa quaisquer anotações existentes e popula com as fornecidas.

#### Parameters

*   `annotations` **[Array][415]<[Annotation][34]>** Um array de anotações para inicializar o repositório.

## calculateViewForMeshes

Calcula múltiplas opções de visualização (padrão, de cima, isométrica) para a câmera
de forma a enquadrar um conjunto de meshes fornecidos.

### Parameters

*   `meshes` **[Array][415]\<THREE.Object3D>** Um array de meshes 3D a serem enquadrados.
*   `camera` **THREE.PerspectiveCamera** A câmera de perspectiva da cena.

Returns **([SystemViewOptions][396] | null)** Um objeto contendo as diferentes visualizações calculadas
ou null se não for possível calcular (e.g., nenhum mesh fornecido).

## createGeometryForItem

Cria e retorna uma `THREE.BufferGeometry` apropriada para o tipo de equipamento.
Seleciona a geometria correta (Box, Cylinder, Sphere) com base no `item.type`
e utiliza as dimensões fornecidas no objeto `item`.

### Parameters

*   `item` **[Equipment][33]** O objeto de equipamento contendo tipo e dimensões.

Returns **THREE.BufferGeometry** A geometria criada para o equipamento.
Retorna um `BoxGeometry(1,1,1)` para tipos desconhecidos.

## updateLabelRendererSize

Atualiza o tamanho do CSS2DRenderer.
Deve ser chamado quando o contêiner de renderização da cena é redimensionado
para garantir que os rótulos sejam dimensionados e posicionados corretamente.

### Parameters

*   `labelRenderer` **(CSS2DRenderer | null)** A instância do CSS2DRenderer a ser atualizada.
*   `width` **[number][427]** A nova largura para o renderizador de rótulos.
*   `height` **[number][427]** A nova altura para o renderizador de rótulos.

Returns **void**&#x20;

## UpdateAnnotationPinsParams

Parâmetros para a função `updateAnnotationPins`.

### Properties

*   `scene` **(THREE.Scene | null)** A cena Three.js onde os pins serão adicionados/removidos.
*   `labelRenderer` **(CSS2DRenderer | null)** O renderizador CSS2D responsável por exibir os pins.
*   `annotations` **[Array][415]<[Annotation][34]>** A lista atual de todas as anotações.
*   `equipmentData` **[Array][415]<[Equipment][33]>** A lista completa de equipamentos, usada para encontrar posições e dimensões dos alvos das anotações.
*   `layers` **[Array][415]<[Layer][392]>** A lista de camadas, usada para verificar a visibilidade da camada de "Annotations".
*   `existingPinsRef` **React.MutableRefObject<[Array][415]\<CSS2DObject>>** Ref para o array de objetos CSS2DObject (pins) atualmente na cena.

## updateAnnotationPins

Atualiza os pins de anotação visíveis na cena 3D.
Remove pins antigos e cria/atualiza novos com base nos dados atuais e na visibilidade da camada de anotações.
Cada pin é um ícone SVG amarelo posicionado acima do equipamento correspondente.
O `labelRenderer.domElement.style.display` é ajustado com base na visibilidade da camada de anotações.

### Parameters

*   `params` **[UpdateAnnotationPinsParams][171]** Parâmetros para atualizar os pins.

    *   `params.scene` &#x20;
    *   `params.labelRenderer` &#x20;
    *   `params.annotations` &#x20;
    *   `params.equipmentData` &#x20;
    *   `params.layers` &#x20;
    *   `params.existingPinsRef` &#x20;

Returns **void**&#x20;

##

Gerencia interações do mouse (clique e movimento) dentro da cena Three.js.

ATENÇÃO: Este arquivo foi esvaziado. A lógica de interação do mouse
foi movida para o hook customizado `src/hooks/use-mouse-interaction.ts`
(renomeado internamente para `useMouseInteractionManager` em termos de funcionalidade)
como parte de uma refatoração para melhorar a modularidade e o Princípio da Responsabilidade Única.

O hook `useMouseInteractionManager` agora encapsula:

*   A lógica de raycasting para detectar interseções.
*   A adição e remoção de ouvintes de eventos do mouse no elemento DOM da cena.
*   A invocação de callbacks para tratar seleção e hover de equipamentos.

Este arquivo é mantido para evitar quebras de importação em locais que ainda
possam referenciá-lo, mas seu conteúdo não é mais utilizado.
Considere remover as importações deste arquivo e usar o hook diretamente.

## setOutlinePassObjects

Define os objetos que devem ser contornados pelo OutlinePass.

### Parameters

*   `outlinePass` **OutlinePass** A instância do OutlinePass.
*   `objectsToOutline` **[Array][415]\<THREE.Object3D>** Um array de objetos 3D a serem contornados.

Returns **void**&#x20;

## applyOutlinePassStyle

Aplica um estilo visual específico ao OutlinePass.
Modifica parâmetros como cor da borda visível, força, espessura e brilho.

### Parameters

*   `outlinePass` **OutlinePass** A instância do OutlinePass.
*   `styleType` **(`"selected"` | `"hover"` | `"none"`)** O tipo de estilo a ser aplicado.

Returns **void**&#x20;

## setupPostProcessing

Configura o pipeline de pós-processamento, incluindo o EffectComposer e o OutlinePass.
Esta função é chamada uma vez durante o setup inicial da cena.

### Parameters

*   `renderer` **THREE.WebGLRenderer** O renderizador WebGL principal.
*   `scene` **THREE.Scene** A cena 3D.
*   `camera` **THREE.PerspectiveCamera** A câmera da cena.
*   `initialWidth` **[number][427]** A largura inicial do canvas de renderização.
*   `initialHeight` **[number][427]** A altura inicial do canvas de renderização.

Returns **{composer: EffectComposer, outlinePass: OutlinePass}** Um objeto contendo o EffectComposer e o OutlinePass configurados.

## updatePostProcessingSize

Atualiza o tamanho do EffectComposer e do OutlinePass.
Deve ser chamado quando o contêiner de renderização é redimensionado.

### Parameters

*   `composer` **(EffectComposer | null)** O EffectComposer a ser atualizado.
*   `outlinePass` **(OutlinePass | null)** O OutlinePass a ser atualizado.
*   `width` **[number][427]** A nova largura.
*   `height` **[number][427]** A nova altura.

Returns **void**&#x20;

## updateOutlineEffect

Atualiza o efeito de contorno (OutlinePass) com base nos equipamentos selecionados e em hover.
Determina quais objetos contornar e qual estilo aplicar.

### Parameters

*   `outlinePass` **(OutlinePass | null)** A instância do OutlinePass.
*   `allMeshes` **[Array][415]\<THREE.Object3D>** A lista de todos os meshes de equipamentos na cena.
*   `selectedTags` **[Array][415]<[string][413]>** As tags dos equipamentos atualmente selecionados.
*   `hoveredTag` **([string][413] | null)** A tag do equipamento atualmente sob o cursor.

Returns **void**&#x20;

## setupLighting

Configura a iluminação padrão para a cena.
Adiciona uma AmbientLight para iluminação geral, uma HemisphereLight para simular luz do céu e do chão,
e uma DirectionalLight para simular luz solar com sombras (atualmente desabilitadas por performance).

### Parameters

*   `scene` **THREE.Scene** A instância da cena Three.js onde as luzes serão adicionadas.

Returns **void**&#x20;

## setupGroundPlane

Configura o plano de chão (terreno) para a cena.
Cria um `THREE.Mesh` com `PlaneGeometry` e `MeshStandardMaterial`.
O plano é posicionado em Y=0 e rotacionado para ficar horizontal.

### Parameters

*   `scene` **THREE.Scene** A instância da cena Three.js onde o plano será adicionado.

Returns **THREE.Mesh** O mesh do plano de chão criado.

## setupRenderPipeline

Configura os renderizadores principais (WebGL, CSS2D) e o pipeline de pós-processamento.
Centraliza a criação do WebGLRenderer, CSS2DRenderer, EffectComposer e OutlinePass.

### Parameters

*   `mountElement` **[HTMLElement][433]** O elemento DOM onde o canvas WebGL e o renderer de labels serão montados.
*   `scene` **THREE.Scene** A cena Three.js.
*   `camera` **THREE.PerspectiveCamera** A câmera da cena.

Returns **({renderer: THREE.WebGLRenderer, labelRenderer: CSS2DRenderer, composer: EffectComposer, outlinePass: OutlinePass} | null)** Um objeto contendo as instâncias configuradas, ou null se mountElement não for válido.

## UpdateEquipmentMeshesParams

Interface para os parâmetros da função `updateEquipmentMeshesInScene`.

### Examples

````javascript
// Representação da interface:
```mermaid
classDiagram
    class UpdateEquipmentMeshesParams {
      +scene: THREE.Scene
      +equipmentMeshesRef: React.MutableRefObject_Object3D_Array_
      +newEquipmentData: Equipment[]
      +layers: Layer[]
      +colorMode: ColorMode
      +createSingleEquipmentMesh(item: Equipment): THREE.Object3D
      +groundMeshRef: React.MutableRefObject_Mesh_
    }
    class Equipment {
    }
    class Layer {
    }
    class ColorMode {
    }
    class THREE_Object3D {
    }
    class THREE_Mesh {
    }
    class THREE_Scene {
    }
    class React_MutableRefObject {
    }

    UpdateEquipmentMeshesParams --> THREE_Scene : scene
    UpdateEquipmentMeshesParams --> React_MutableRefObject : equipmentMeshesRef
    UpdateEquipmentMeshesParams --> React_MutableRefObject : groundMeshRef
    React_MutableRefObject --> THREE_Object3D : (array for equipment)
    React_MutableRefObject --> THREE_Mesh : (for ground)
    UpdateEquipmentMeshesParams --> Equipment : newEquipmentData (array)
    UpdateEquipmentMeshesParams --> Layer : layers (array)
    UpdateEquipmentMeshesParams --> ColorMode : colorMode

    style UpdateEquipmentMeshesParams fill:#DCDCDC,stroke:#333,stroke-width:2px,color:black
    style Equipment,Layer,ColorMode,THREE_Object3D,THREE_Mesh,THREE_Scene,React_MutableRefObject fill:#FFFFE0,stroke:#333,stroke-width:2px,color:black
```
````

## updateEquipmentMeshesInScene

Atualiza a lista de meshes de equipamentos na cena com base nos novos dados.
Remove meshes antigos, atualiza existentes (recriando-os para garantir consistência de material/cor)
e adiciona novos, considerando a visibilidade das camadas. Também gerencia a visibilidade do plano de chão.
Esta função é otimizada para recriar meshes apenas quando necessário, mas a lógica atual recria
para simplificar a atualização de cor e outras propriedades visuais baseadas em `colorMode` ou dados do equipamento.

### Parameters

*   `params` **[UpdateEquipmentMeshesParams][192]** Os parâmetros para a função.

    *   `params.scene` &#x20;
    *   `params.equipmentMeshesRef` &#x20;
    *   `params.newEquipmentData` &#x20;
    *   `params.layers` &#x20;
    *   `params.colorMode` &#x20;
    *   `params.createSingleEquipmentMesh` &#x20;
    *   `params.groundMeshRef` &#x20;

Returns **void**&#x20;

## UseAnimationLoopProps

Props para o hook `useAnimationLoop`.

### Properties

*   `isSceneReady` **[boolean][414]** Flag que indica se a cena e todos os seus componentes dependentes
    (câmera, renderizadores, controles) estão prontos para iniciar o loop de animação.
*   `sceneRef` **RefObject<(THREE.Scene | null)>** Ref para o objeto da cena Three.js.
*   `cameraRef` **RefObject<(THREE.PerspectiveCamera | null)>** Ref para o objeto da câmera perspectiva.
*   `controlsRef` **RefObject<(OrbitControls | null)>** Ref para os `OrbitControls`.
*   `composerRef` **RefObject<(EffectComposer | null)>** Ref para o `EffectComposer` (usado para pós-processamento).
*   `labelRendererRef` **RefObject<(CSS2DRenderer | null)>** Ref para o `CSS2DRenderer` (usado para rótulos HTML).

## useAnimationLoop

Hook customizado para gerenciar o loop de animação de uma cena Three.js.
Ele configura e executa o `requestAnimationFrame` para renderizar a cena
e atualizar os controles, o composer e o renderizador de rótulos.
O loop só é iniciado quando `isSceneReady` é verdadeiro e todos os refs necessários estão populados.

### Parameters

*   `props` **[UseAnimationLoopProps][196]** As props necessárias para o loop de animação.

    *   `props.isSceneReady` &#x20;
    *   `props.sceneRef` &#x20;
    *   `props.cameraRef` &#x20;
    *   `props.controlsRef` &#x20;
    *   `props.composerRef` &#x20;
    *   `props.labelRendererRef` &#x20;
    *   `props.onFrameUpdate` &#x20;

Returns **void**&#x20;

##

*   **See**: [../../core/repository/memory-repository/README.md#annotationRepository][434] Para a fonte de dados das anotações.
*   **See**: [../../core/repository/memory-repository/README.md#equipmentRepository][435] Para obter dados de equipamentos (e.g., nome para toasts).
*   **See**: [../../lib/types/README.md#Annotation][436] Para a interface de Anotação.
*   **See**: [../../lib/types/README.md#Equipment][437] Para a interface de Equipamento.

### Parameters

*   `props`  Propriedades de configuração para o hook (atualmente, `initialAnnotations` é opcional e usado para uma potencial inicialização única do repositório, embora o repositório seja auto-inicializável).

### Examples

````javascript
// Diagrama de Interação do useAnnotationManager:
```mermaid
graph TD
    A[Componente UI (ex: InfoPanel)] -- chama --> B(handleOpenAnnotationDialog)
    B -- define estados --> DialogState["isAnnotationDialogOpen, editingAnnotation, annotationTargetEquipment"]

    C[Componente UI (ex: AnnotationDialog)] -- no submit --> D(handleSaveAnnotation)

    subgraph useAnnotationManager [Hook useAnnotationManager]
        direction LR
        D -- chama --> E[annotationRepository.addOrUpdateAnnotation]
        E -- retorna --> D{Anotação Salva}
        D -- chama --> F[refreshAnnotationsFromRepo]
        F -- chama --> G[annotationRepository.getAllAnnotations]
        G -- retorna --> H[setAnnotationsState (Estado React)]
        H -- atualiza --> I[annotations (Estado React)]
        D -- chama --> J[toast]
        DialogState
    end

    I -- usado por --> A
    DialogState -- usado por --> C

   classDef hook fill:#lightblue,stroke:#333,stroke-width:2px;
   classDef state fill:#lightgoldenrodyellow,stroke:#333,stroke-width:2px;
   classDef func fill:#lightgreen,stroke:#333,stroke-width:2px;
   classDef repo fill:#lightcoral,stroke:#333,stroke-width:2px;
   classDef ui fill:#peachpuff,stroke:#333,stroke-width:2px;

   class A,C ui;
   class B,D,F,J func;
   class E,G repo;
   class DialogState,H,I state;
   class useAnnotationManager hook;
```
````

Returns **any** Objeto contendo o estado das anotações, o estado do diálogo e funções para manipular anotações.

## UseAnnotationManagerProps

Props para o hook `useAnnotationManager`.

### Properties

*   `initialAnnotations` **[Array][415]<[Annotation][34]>?** Lista inicial opcional de anotações. Pode ser usada para uma
    inicialização única do repositório se ele estiver vazio e este array contiver dados.
    No entanto, o `annotationRepository` é geralmente auto-inicializável.

## UseAnnotationManagerProps

Props para o hook `useAnnotationManager`.

### Properties

*   `initialAnnotations` **[Array][415]<[Annotation][34]>?** Lista inicial opcional de anotações. Pode ser usada para uma
    inicialização única do repositório se ele estiver vazio e este array contiver dados.
    No entanto, o `annotationRepository` é geralmente auto-inicializável.

## UseAnnotationManagerReturn

Retorno do hook `useAnnotationManager`.

### Properties

*   `annotations` **[Array][415]<[Annotation][34]>** A lista atual de todas as anotações (cópia local do estado do repositório).
*   `isAnnotationDialogOpen` **[boolean][414]** Indica se o diálogo de anotação está aberto.
*   `annotationTargetEquipment` **([Equipment][33] | null)** O equipamento que é o alvo atual para adicionar/editar uma anotação.
*   `editingAnnotation` **([Annotation][34] | null)** A anotação que está atualmente em edição no diálogo (null se for uma nova anotação).
*   `setIsAnnotationDialogOpen` **React.Dispatch\<React.SetStateAction<[boolean][414]>>** Função para definir o estado de abertura/fechamento do diálogo.

## UseAnnotationManagerReturn

Retorno do hook `useAnnotationManager`.

### Properties

*   `annotations` **[Array][415]<[Annotation][34]>** A lista atual de todas as anotações (cópia local do estado do repositório).
*   `isAnnotationDialogOpen` **[boolean][414]** Indica se o diálogo de anotação está aberto.
*   `annotationTargetEquipment` **([Equipment][33] | null)** O equipamento que é o alvo atual para adicionar/editar uma anotação.
*   `editingAnnotation` **([Annotation][34] | null)** A anotação que está atualmente em edição no diálogo (null se for uma nova anotação).
*   `setIsAnnotationDialogOpen` **React.Dispatch\<React.SetStateAction<[boolean][414]>>** Função para definir o estado de abertura/fechamento do diálogo.

## useAnnotationManager

Hook customizado para gerenciar anotações textuais associadas a equipamentos.
Atua como uma fachada para o `annotationRepository`, gerenciando o estado do diálogo de edição
e sincronizando o estado local de anotações com o repositório.

### Parameters

*   `props` **[UseAnnotationManagerProps][203]** Propriedades de configuração para o hook.

    *   `props.initialAnnotations`   (optional, default `[]`)

Returns **[UseAnnotationManagerReturn][207]** Um objeto contendo o estado das anotações e funções para manipulá-las.

## useAnnotationManager

Hook customizado para gerenciar anotações textuais associadas a equipamentos.
Atua como uma fachada para o `annotationRepository`, gerenciando o estado do diálogo de edição
e sincronizando o estado local de anotações com o repositório.

### Parameters

*   `props` **[UseAnnotationManagerProps][203]** Propriedades de configuração para o hook.

    *   `props.initialAnnotations`   (optional, default `[]`)

Returns **[UseAnnotationManagerReturn][207]** Um objeto contendo o estado das anotações e funções para manipulá-las.

## refreshAnnotationsFromRepo

Atualiza o estado local de anotações buscando os dados mais recentes do `annotationRepository`.

## refreshAnnotationsFromRepo

Atualiza o estado local de anotações buscando os dados mais recentes do `annotationRepository`.

## handleOpenAnnotationDialog

Abre o diálogo de anotação para um equipamento específico.
Se o equipamento já possui uma anotação, preenche o diálogo para edição.

### Parameters

*   `equipment` **([Equipment][33] | null)** O equipamento para o qual a anotação será gerenciada.

## handleOpenAnnotationDialog

Abre o diálogo de anotação para um equipamento específico.
Se o equipamento já possui uma anotação, preenche o diálogo para edição.

### Parameters

*   `equipment` **([Equipment][33] | null)** O equipamento para o qual a anotação será gerenciada.

## handleSaveAnnotation

Salva uma anotação (nova ou existente) para o `annotationTargetEquipment`.
Atualiza a data de criação/modificação, persiste no repositório e atualiza o estado local.

### Parameters

*   `text` **[string][413]** O texto da anotação a ser salvo.

## handleSaveAnnotation

Salva uma anotação (nova ou existente) para o `annotationTargetEquipment`.
Atualiza a data de criação/modificação, persiste no repositório e atualiza o estado local.

### Parameters

*   `text` **[string][413]** O texto da anotação a ser salvo.

## handleDeleteAnnotation

Exclui a anotação de um equipamento específico.
Remove do repositório e atualiza o estado local.

### Parameters

*   `equipmentTag` **[string][413]** A tag do equipamento cuja anotação será excluída.

## handleDeleteAnnotation

Exclui a anotação de um equipamento específico.
Remove do repositório e atualiza o estado local.

### Parameters

*   `equipmentTag` **[string][413]** A tag do equipamento cuja anotação será excluída.

## getAnnotationForEquipment

Obtém a anotação para um equipamento específico diretamente do repositório.

### Parameters

*   `equipmentTag` **([string][413] | null)** A tag do equipamento. Se null, retorna null.

Returns **([Annotation][34] | null)** A anotação encontrada (uma cópia), ou null se não existir.

## getAnnotationForEquipment

Obtém a anotação para um equipamento específico diretamente do repositório.

### Parameters

*   `equipmentTag` **([string][413] | null)** A tag do equipamento. Se null, retorna null.

Returns **([Annotation][34] | null)** A anotação encontrada (uma cópia), ou null se não existir.

## UseAnnotationPinRendererProps

Custom hook para gerenciar a renderização de pins de anotação na cena 3D.

Principal Responsabilidade:
Encapsular a lógica de criação, atualização e remoção dos `CSS2DObject` (pins)
que representam as anotações. Observa mudanças nas anotações, dados dos equipamentos
(para posicionamento), e camadas de visibilidade, atualizando os pins conforme necessário.
Utiliza `updateAnnotationPins` de `label-renderer-utils.ts` para a lógica de sincronização.

```mermaid
  classDiagram
    class UseAnnotationPinRendererProps {
      +sceneRef: RefObject_Scene_
      +labelRendererRef: RefObject_CSS2DRenderer_
      +isSceneReady: boolean
      +annotations: Annotation[]
      +allEquipmentData: Equipment[] // Full list for correct positioning
      +layers: Layer[]
    }
    class useAnnotationPinRenderer {

    }
    class ReactFCHook {

    }
    class label_renderer_utils{

    }
    class Annotation {

    }
    class Equipment {

    }
    class Layer {

    }
    class RefObject_Scene_ {

    }
    class RefObject_CSS2DRenderer_ {

    }
    useAnnotationPinRenderer --|> ReactFCHook
    useAnnotationPinRenderer ..> label_renderer_utils : uses updateAnnotationPins
    UseAnnotationPinRendererProps ..> Annotation
    UseAnnotationPinRendererProps ..> Equipment
    UseAnnotationPinRendererProps ..> Layer
    UseAnnotationPinRendererProps ..> RefObject_Scene_
    UseAnnotationPinRendererProps ..> RefObject_CSS2DRenderer_
```

## useAnnotationPinRenderer

Hook customizado para gerenciar a renderização (criação, atualização, remoção)
dos pins de anotação (`CSS2DObject`) na cena.

### Parameters

*   `props` **[UseAnnotationPinRendererProps][233]** As props do hook.

    *   `props.sceneRef` &#x20;
    *   `props.labelRendererRef` &#x20;
    *   `props.isSceneReady` &#x20;
    *   `props.annotations` &#x20;
    *   `props.allEquipmentData` &#x20;
    *   `props.layers` &#x20;

Returns **void**&#x20;

##

*   **See**: [../../lib/types/README.md#CameraState][438] Para a interface do estado da câmera.
*   **See**: [../../lib/types/README.md#Command][439] Para a interface de comando (usada com `executeCommand`).
*   **See**: [../../lib/types/README.md#TargetSystemInfo][440] Para a interface de informações do sistema alvo.

### Parameters

*   `props`  Propriedades para o hook, incluindo `executeCommand` para integração com histórico.

### Examples

````javascript
// Diagrama de Interação e Estado do useCameraManager:
```mermaid
graph LR
    A[Terminal3DPage] -- chama --> B(handleSetCameraViewForSystem)
    B -- atualiza --> C{targetSystemToFrame};
    C -- atualiza --> D{focusedSystemNameUI};
    C -- atualiza --> E{currentViewIndexUI};
    A -- passa targetSystemToFrame --> F[ThreeScene]

    F -- anima câmera e ao final chama --> G(onSystemFramed)
    G -- limpa --> C;
    F -- em interações manuais, chama --> H(handleCameraChangeFromScene)

    H -- cria comando --> I{Comando}
    H -- chama --> J(executeCommand)
    J -- executa e salva --> I

    subgraph useCameraManager [Hook useCameraManager]
        direction LR
        B
        G
        H
        C
        D
        E
        K[currentCameraState (Estado React)]
        L[lastCommittedCameraStateForUndoRef (Ref)]
    end

    I -- no execute/undo --> M{setCurrentCameraState}
    M -- atualiza --> K
    K -- usado por --> F

   classDef hook fill:#lightblue,stroke:#333,stroke-width:2px;
   classDef state fill:#lightgoldenrodyellow,stroke:#333,stroke-width:2px;
   classDef func fill:#lightgreen,stroke:#333,stroke-width:2px;
   classDef comp fill:#lightcoral,stroke:#333,stroke-width:2px;

   class A,F comp;
   class B,G,H,J,M func;
   class C,D,E,K,L,I state;
   class useCameraManager hook;
```
````

Returns **any** Objeto contendo o estado da câmera, informações de foco, e funções para interagir com a câmera.

## defaultInitialCameraPosition

Posição inicial padrão da câmera: { x: 25, y: 20, z: 25 }.

## defaultInitialCameraPosition

Posição inicial padrão da câmera: { x: 25, y: 20, z: 25 }.

## defaultInitialCameraLookAt

Ponto de observação (lookAt) inicial padrão da câmera: { x: 0, y: 2, z: 0 }.

## defaultInitialCameraLookAt

Ponto de observação (lookAt) inicial padrão da câmera: { x: 0, y: 2, z: 0 }.

## UseCameraManagerProps

Props para o hook `useCameraManager`.

## UseCameraManagerProps

Props para o hook `useCameraManager`.

## UseCameraManagerReturn

Retorno do hook `useCameraManager`.

### Properties

*   `currentCameraState` **[CameraState][394]** O estado atual da câmera (posição e ponto de observação).
*   `targetSystemToFrame` **([TargetSystemInfo][398] | null)** O sistema alvo e o índice da visão para a câmera enquadrar. Null se nenhum foco ativo.
*   `focusedSystemNameUI` **([string][413] | null)** O nome do sistema atualmente focado (para UI, pode persistir mesmo após `targetSystemToFrame` ser limpo).
*   `currentViewIndexUI` **[number][427]** O índice da visão atual para o sistema focado (para UI).

## UseCameraManagerReturn

Retorno do hook `useCameraManager`.

### Properties

*   `currentCameraState` **[CameraState][394]** O estado atual da câmera (posição e ponto de observação).
*   `targetSystemToFrame` **([TargetSystemInfo][398] | null)** O sistema alvo e o índice da visão para a câmera enquadrar. Null se nenhum foco ativo.
*   `focusedSystemNameUI` **([string][413] | null)** O nome do sistema atualmente focado (para UI, pode persistir mesmo após `targetSystemToFrame` ser limpo).
*   `currentViewIndexUI` **[number][427]** O índice da visão atual para o sistema focado (para UI).

## useCameraManager

Hook customizado para gerenciar o estado e as interações da câmera 3D.
Responsável pelo estado da câmera, foco em sistemas e integração com o histórico de comandos.

### Parameters

*   `props` **[UseCameraManagerProps][243]** As props do hook, incluindo `executeCommand` para integração com o histórico.

    *   `props.executeCommand` &#x20;

Returns **[UseCameraManagerReturn][245]** Um objeto contendo o estado da câmera e funções para interagir com ela.

## useCameraManager

Hook customizado para gerenciar o estado e as interações da câmera 3D.
Responsável pelo estado da câmera, foco em sistemas e integração com o histórico de comandos.

### Parameters

*   `props` **[UseCameraManagerProps][243]** As props do hook, incluindo `executeCommand` para integração com o histórico.

    *   `props.executeCommand` &#x20;

Returns **[UseCameraManagerReturn][245]** Um objeto contendo o estado da câmera e funções para interagir com ela.

## handleSetCameraViewForSystem

Define o sistema alvo e o índice da visão para a câmera enquadrar.
Se o mesmo sistema é clicado repetidamente, cicla entre as visualizações disponíveis.

### Parameters

*   `systemName` **[string][413]** O nome do sistema para focar.

## handleSetCameraViewForSystem

Define o sistema alvo e o índice da visão para a câmera enquadrar.
Se o mesmo sistema é clicado repetidamente, cicla entre as visualizações disponíveis.

### Parameters

*   `systemName` **[string][413]** O nome do sistema para focar.

## handleCameraChangeFromScene

Manipula mudanças de câmera provenientes da cena 3D (e.g., interações do usuário com OrbitControls)
ou de animações programáticas concluídas. Registra a mudança no histórico de comandos.

### Parameters

*   `newSceneCameraState` **[CameraState][394]** O novo estado da câmera.
*   `actionDescription` **[string][413]?** Descrição opcional da ação para o histórico (e.g., "Foco no sistema X").

## handleCameraChangeFromScene

Manipula mudanças de câmera provenientes da cena 3D (e.g., interações do usuário com OrbitControls)
ou de animações programáticas concluídas. Registra a mudança no histórico de comandos.

### Parameters

*   `newSceneCameraState` **[CameraState][394]** O novo estado da câmera.
*   `actionDescription` **[string][413]?** Descrição opcional da ação para o histórico (e.g., "Foco no sistema X").

## onSystemFramed

Callback para ser chamado pela `ThreeScene` após o enquadramento do sistema ser concluído.
Reseta `targetSystemToFrame`, indicando que o processo de foco foi finalizado.

## onSystemFramed

Callback para ser chamado pela `ThreeScene` após o enquadramento do sistema ser concluído.
Reseta `targetSystemToFrame`, indicando que o processo de foco foi finalizado.

## Command

### Examples

````javascript
// Diagrama de Estrutura do Hook e seus Retornos:
```mermaid
  classDiagram
    class UseCommandHistoryReturn {
      +executeCommand(command: Command): void
      +undo(): void
      +redo(): void
      +canUndo: boolean
      +canRedo: boolean
      +commandHistory: Command[]
    }
    class Command {
      +id: string
      +type: string
      +description: string
      +execute(): void
      +undo(): void
    }
    UseCommandHistoryReturn ..> Command : manages array of
    class useCommandHistory {
      -state: CommandHistoryState
      +executeCommand()
      +undo()
      +redo()
    }
    useCommandHistory --|> UseCommandHistoryReturn : returns
```
````

## Command

Representa um comando executável e reversível para o sistema de Undo/Redo.
Cada ação do usuário que pode ser desfeita (e.g., mover a câmera, alternar visibilidade de camada,
selecionar equipamento) deve ser encapsulada como um `Command`.

### Properties

*   `id` **[string][413]** Identificador único do comando, geralmente incluindo um timestamp para unicidade.
*   `type` **(`"CAMERA_MOVE"` | `"LAYER_VISIBILITY"` | `"EQUIPMENT_SELECT"`)** Tipo do comando, para categorização.
*   `description` **[string][413]** Descrição textual do comando, usada para logging ou exibição na UI (e.g., em toasts de undo/redo).

## CommandHistoryState

Interface para o estado interno do histórico de comandos.

### Properties

*   `history` **[Array][415]<[Command][263]>** Array de objetos de comando que foram executados.
*   `currentIndex` **[number][427]** Índice do comando atual no array `history`.
    -1 se o histórico estiver vazio ou todos os comandos foram desfeitos.

## UseCommandHistoryReturn

Retorno do hook `useCommandHistory`.

### Properties

*   `canUndo` **[boolean][414]** Verdadeiro se há comandos para desfazer, falso caso contrário.
*   `canRedo` **[boolean][414]** Verdadeiro se há comandos para refazer, falso caso contrário.
*   `commandHistory` **[Array][415]<[Command][263]>** O array completo do histórico de comandos, principalmente para depuração.

## useCommandHistory

Hook customizado para gerenciar um histórico de comandos, permitindo Undo e Redo.
Armazena uma lista de comandos e o índice atual, permitindo navegar para frente e para trás
através das ações do usuário que foram encapsuladas como comandos.

### Parameters

*   `initialState` **[CommandHistoryState][267]?** Estado inicial opcional para o histórico.
    Padrão: histórico vazio (`history: []`) e `currentIndex: -1`.

Returns **[UseCommandHistoryReturn][269]** Um objeto com funções para executar, desfazer, refazer comandos,
e flags indicando se undo/redo são possíveis, além do próprio histórico.

## executeCommand

Executa um comando e o adiciona ao histórico.
Se houver comandos "futuros" (comandos que foram desfeitos e poderiam ser refeitos),
eles são descartados, pois uma nova ação invalida essa linha do tempo de redo.

### Parameters

*   `command` **[Command][263]** O comando a ser executado. A função `command.execute()` é chamada.

## undo

Desfaz o último comando executado (o comando no `currentIndex`).
Se não houver comandos para desfazer (`currentIndex < 0`), não faz nada.
Chama a função `undo()` do comando.

## redo

Refaz o último comando desfeito (o comando após o `currentIndex`).
Se não houver comandos para refazer (`currentIndex` já é o último do histórico), não faz nada.
Chama a função `execute()` do comando a ser refeito.

##

*   **See**: [../../core/repository/memory-repository/README.md#equipmentRepository][435] Para a fonte de dados.
*   **See**: [../../lib/types/README.md#Equipment][437] Para a interface de Equipamento.

### Examples

````javascript
// Diagrama de Interação do useEquipmentDataManager:
```mermaid
graph TD
    A[Componente UI (ex: InfoPanel)] -- chama --> B(handleOperationalStateChange)

    subgraph useEquipmentDataManager [Hook useEquipmentDataManager]
        direction LR
        B -- chama --> C[equipmentRepository.updateEquipment]
        C -- retorna --> B{Equipamento Atualizado}
        B -- chama --> D[equipmentRepository.getAllEquipment]
        D -- retorna --> E[setEquipmentData (Estado React)]
        E -- atualiza --> F[equipmentData (Estado React)]
        B -- chama --> G[toast]
    end

    F -- usado por --> A

   classDef hook fill:#lightblue,stroke:#333,stroke-width:2px;
   classDef state fill:#lightgoldenrodyellow,stroke:#333,stroke-width:2px;
   classDef func fill:#lightgreen,stroke:#333,stroke-width:2px;
   classDef repo fill:#lightcoral,stroke:#333,stroke-width:2px;
   classDef ui fill:#peachpuff,stroke:#333,stroke-width:2px;

   class A ui;
   class B,G func;
   class C,D repo;
   class E,F state;
   class useEquipmentDataManager hook;
```
````

Returns **any** Objeto contendo os dados dos equipamentos e funções para modificá-los e atualizá-los.

## UseEquipmentDataManagerReturn

Retorno do hook `useEquipmentDataManager`.

### Properties

*   `equipmentData` **[Array][415]<[Equipment][33]>** A lista atual de todos os equipamentos (cópia local do estado do repositório).

## UseEquipmentDataManagerReturn

Retorno do hook `useEquipmentDataManager`.

### Properties

*   `equipmentData` **[Array][415]<[Equipment][33]>** A lista atual de todos os equipamentos (cópia local do estado do repositório).

## useEquipmentDataManager

Hook customizado para gerenciar os dados dos equipamentos, atuando como uma fachada para o `equipmentRepository`.
Inicializa os dados do repositório e fornece funções para modificar
propriedades como estado operacional e produto, com feedback via toast.

Returns **[UseEquipmentDataManagerReturn][279]** Um objeto contendo os dados dos equipamentos
e funções para modificá-los.

## useEquipmentDataManager

Hook customizado para gerenciar os dados dos equipamentos, atuando como uma fachada para o `equipmentRepository`.
Inicializa os dados do repositório e fornece funções para modificar
propriedades como estado operacional e produto, com feedback via toast.

Returns **[UseEquipmentDataManagerReturn][279]** Um objeto contendo os dados dos equipamentos
e funções para modificá-los.

## refreshEquipmentData

Recarrega os dados dos equipamentos do repositório para o estado local do hook.

## refreshEquipmentData

Recarrega os dados dos equipamentos do repositório para o estado local do hook.

## handleOperationalStateChange

Manipula a alteração do estado operacional de um equipamento.
Atualiza o repositório e, em seguida, o estado local do hook.

### Parameters

*   `equipmentTag` **[string][413]** A tag do equipamento a ser modificado.
*   `newState` **[string][413]** O novo estado operacional para o equipamento.

## handleOperationalStateChange

Manipula a alteração do estado operacional de um equipamento.
Atualiza o repositório e, em seguida, o estado local do hook.

### Parameters

*   `equipmentTag` **[string][413]** A tag do equipamento a ser modificado.
*   `newState` **[string][413]** O novo estado operacional para o equipamento.

## handleProductChange

Manipula a alteração do produto de um equipamento.
Atualiza o repositório e, em seguida, o estado local do hook.

### Parameters

*   `equipmentTag` **[string][413]** A tag do equipamento a ser modificado.
*   `newProduct` **[string][413]** O novo produto para o equipamento.

## handleProductChange

Manipula a alteração do produto de um equipamento.
Atualiza o repositório e, em seguida, o estado local do hook.

### Parameters

*   `equipmentTag` **[string][413]** A tag do equipamento a ser modificado.
*   `newProduct` **[string][413]** O novo produto para o equipamento.

## UseEquipmentRendererProps

### Examples

````javascript
// Diagrama de Composição e Dependências:
```mermaid
  classDiagram
    class UseEquipmentRendererProps {
      +sceneRef: RefObject_Scene_
      +cameraRef: RefObject_PerspectiveCamera_
      +controlsRef: RefObject_OrbitControls_
      +isSceneReady: boolean
      +isControlsReady: boolean
      +equipmentData: Equipment[]  // Lista filtrada
      +layers: Layer[]
      +colorMode: ColorMode
      +createSingleEquipmentMesh(item: Equipment): Object3D
      +groundMeshRef: RefObject_Mesh_
    }
    class useEquipmentRenderer {
      #equipmentMeshesRef: React.MutableRefObject_Object3D[]
    }
    class ReactFCHook {
    }
    class scene_elements_setup_module {
      +updateEquipmentMeshesInScene()
    }
    class Equipment {
    }
    class Layer {
    }
    class ColorMode {
    }
    class RefObject_Scene_ {
    }
    class RefObject_PerspectiveCamera_ {
    }
    class RefObject_OrbitControls_ {
    }
    class RefObject_Mesh_ {
    }
    useEquipmentRenderer --|> ReactFCHook
    useEquipmentRenderer ..> scene_elements_setup_module : uses updateEquipmentMeshesInScene
    UseEquipmentRendererProps ..> Equipment
    UseEquipmentRendererProps ..> Layer
    UseEquipmentRendererProps ..> ColorMode
    UseEquipmentRendererProps ..> RefObject_Scene_
    UseEquipmentRendererProps ..> RefObject_Mesh_
    UseEquipmentRendererProps ..> RefObject_PerspectiveCamera_
    UseEquipmentRendererProps ..> RefObject_OrbitControls_
```
````

## useEquipmentRenderer

Hook customizado para gerenciar a renderização (criação, atualização, remoção)
dos meshes de equipamentos na cena Three.js.

### Parameters

*   `props` **[UseEquipmentRendererProps][295]** As props do hook.

    *   `props.sceneRef` &#x20;
    *   `props.cameraRef` &#x20;
    *   `props.controlsRef` &#x20;
    *   `props.isSceneReady` &#x20;
    *   `props.isControlsReady` &#x20;
    *   `props.equipmentData` &#x20;
    *   `props.layers` &#x20;
    *   `props.colorMode` &#x20;
    *   `props.createSingleEquipmentMesh` &#x20;
    *   `props.groundMeshRef` &#x20;

Returns **React.RefObject<[Array][415]\<THREE.Object3D>>** Ref para a lista de meshes de equipamentos atualmente na cena.
Este ref é gerenciado internamente pelo hook mas retornado para que outros hooks
(e.g., para raycasting) possam acessá-lo.

##

Custom hook para gerenciar o estado e a lógica de seleção e hover de equipamentos na cena 3D.

Principal Responsabilidade:
Manter o estado dos equipamentos selecionados e em hover, e fornecer funções para
manipular essas seleções (clique único, clique múltiplo, seleção em lote).
Integra-se com `useCommandHistory` para registrar ações de seleção e `useToast` para feedback.

```mermaid
  classDiagram
    class UseEquipmentSelectionManagerProps {
      +equipmentData: Equipment[]
      +executeCommand(command: Command): void
    }
    class UseEquipmentSelectionManagerReturn {
      +selectedEquipmentTags: string[]
      +hoveredEquipmentTag: string | null
      +handleEquipmentClick(tag: string | null, isMultiSelectModifierPressed: boolean): void
      +handleSetHoveredEquipmentTag(tag: string | null): void
      +selectTagsBatch(tagsToSelect: string[], operationDescription?: string): void
    }
    class Equipment {

    }
    class Command {

    }
    UseEquipmentSelectionManagerProps ..> Equipment : uses (via equipmentData for names)
    UseEquipmentSelectionManagerProps ..> Command : uses (via executeCommand)
    UseEquipmentSelectionManagerReturn ..> Command
    class useEquipmentSelectionManager {

    }
    useEquipmentSelectionManager ..> useToast : uses
```

## UseEquipmentSelectionManagerProps

Props para o hook `useEquipmentSelectionManager`.

### Properties

*   `equipmentData` **[Array][415]<[Equipment][33]>** Lista completa de todos os equipamentos. Usada para buscar nomes
    de equipamentos para mensagens de feedback (toasts).

## UseEquipmentSelectionManagerReturn

Retorno do hook `useEquipmentSelectionManager`.

### Properties

*   `selectedEquipmentTags` **[Array][415]<[string][413]>** Array das tags dos equipamentos atualmente selecionados.
*   `hoveredEquipmentTag` **([string][413] | null)** Tag do equipamento atualmente sob o cursor do mouse, ou null.

## useEquipmentSelectionManager

Hook customizado para gerenciar a seleção e o estado de hover dos equipamentos.
Encapsula a lógica de seleção única/múltipla, hover, seleção em lote e integração com o histórico de comandos.

### Parameters

*   `props` **[UseEquipmentSelectionManagerProps][300]** As props do hook.

    *   `props.equipmentData` &#x20;
    *   `props.executeCommand` &#x20;

Returns **[UseEquipmentSelectionManagerReturn][302]** O estado da seleção e as funções para manipulá-la.

## handleEquipmentClick

Manipula o clique em um equipamento na cena 3D para seleção.
Gerencia seleção única, múltipla (com Ctrl/Cmd) e deseleção.
Cria e executa um comando para o histórico de Undo/Redo.

### Parameters

*   `tag` **([string][413] | null)** A tag do equipamento clicado, ou null se o clique foi em espaço vazio.
*   `isMultiSelectModifierPressed` **[boolean][414]** True se Ctrl/Cmd (ou Meta) foi pressionado durante o clique.

## handleSetHoveredEquipmentTag

Define diretamente a tag do equipamento sob o cursor.
Esta função é geralmente chamada em resposta a eventos de mousemove na cena 3D.

### Parameters

*   `tag` **([string][413] | null)** A tag do equipamento, ou null se nenhum estiver sob o cursor.

## selectTagsBatch

Seleciona programaticamente um conjunto de tags de equipamento.
Usado, por exemplo, ao focar em um sistema para selecionar todos os seus equipamentos.
Cria e executa um comando para o histórico de Undo/Redo.

### Parameters

*   `tagsToSelect` **[Array][415]<[string][413]>** Array de tags de equipamento a serem selecionadas.
*   `operationDescription` **[string][413]?** Descrição opcional para o comando no histórico (e para o toast).
    Padrão: "Selecionados X equipamentos em lote."

##

### Examples

````javascript
// Diagrama de Estrutura do Hook e suas Dependências:
```mermaid
  classDiagram
    class UseFilterManagerProps {
      +allEquipment: Equipment[]
    }
    class UseFilterManagerReturn {
      +searchTerm: string
      +setSearchTerm(value: string): void
      +selectedSistema: string
      +setSelectedSistema(value: string): void
      +selectedArea: string
      +setSelectedArea(value: string): void
      +availableSistemas: string[]
      +availableAreas: string[]
      +filteredEquipment: Equipment[]
    }
    class Equipment {
      +tag: string
      +name: string
      +type: string
      +sistema?: string
      +area?: string
    }
    class equipment_filter_module {
      +getFilteredEquipment(allEquipment: Equipment[], criteria: EquipmentFilterCriteria): Equipment[]
    }
    class EquipmentFilterCriteria {
    }
    UseFilterManagerProps ..> Equipment
    UseFilterManagerReturn ..> Equipment
    class useFilterManager {
      -searchTerm: string
      -selectedSistema: string
      -selectedArea: string
      +setSearchTerm()
      +setSelectedSistema()
      +setSelectedArea()
    }
    useFilterManager --|> UseFilterManagerReturn : returns
    useFilterManager ..> equipment_filter_module : uses getFilteredEquipment
    equipment_filter_module ..> EquipmentFilterCriteria : uses
```
````

## UseFilterManagerProps

Props para o hook `useFilterManager`.

### Properties

*   `allEquipment` **[Array][415]<[Equipment][33]>** A lista completa de todos os equipamentos que podem ser filtrados.

## UseFilterManagerReturn

Retorno do hook `useFilterManager`.

### Properties

*   `searchTerm` **[string][413]** O termo de busca textual atualmente aplicado.
*   `setSearchTerm` **Dispatch\<SetStateAction<[string][413]>>** Função para atualizar o `searchTerm`.
*   `selectedSistema` **[string][413]** O sistema atualmente selecionado para filtro (e.g., "GA", "All").
*   `setSelectedSistema` **Dispatch\<SetStateAction<[string][413]>>** Função para atualizar o `selectedSistema`.
*   `selectedArea` **[string][413]** A área atualmente selecionada para filtro (e.g., "Área 31", "All").
*   `setSelectedArea` **Dispatch\<SetStateAction<[string][413]>>** Função para atualizar o `selectedArea`.
*   `availableSistemas` **[Array][415]<[string][413]>** Lista ordenada de sistemas únicos disponíveis para seleção no filtro, incluindo "All".
*   `availableAreas` **[Array][415]<[string][413]>** Lista ordenada de áreas únicas disponíveis para seleção no filtro, incluindo "All".
*   `filteredEquipment` **[Array][415]<[Equipment][33]>** A lista de equipamentos resultante após a aplicação de todos os filtros ativos.

## useFilterManager

Hook customizado para gerenciar a lógica de filtragem de equipamentos.
Encapsula os estados dos filtros (termo de busca, sistema, área),
deriva as listas de opções de filtro disponíveis a partir dos dados dos equipamentos,
e calcula a lista resultante de equipamentos filtrados.

### Parameters

*   `props` **[UseFilterManagerProps][314]** As propriedades para o hook, incluindo `allEquipment` (a lista completa de equipamentos).

    *   `props.allEquipment` &#x20;

Returns **[UseFilterManagerReturn][316]** Um objeto contendo o estado dos filtros, as funções para atualizá-los,
as listas de opções de filtro disponíveis e a lista de equipamentos filtrados.

## availableSistemas

Lista de sistemas únicos disponíveis, derivada de `allEquipment`.
Inclui "All" como a primeira opção e é ordenada alfabeticamente.
Memoizada para otimizar performance, recalculando apenas se `allEquipment` mudar.

## availableAreas

Lista de áreas únicas disponíveis, derivada de `allEquipment`.
Inclui "All" como a primeira opção e é ordenada alfabeticamente.
Memoizada para otimizar performance.

## filteredEquipment

Lista de equipamentos filtrada com base nos critérios atuais (`searchTerm`, `selectedSistema`, `selectedArea`).
Utiliza a função `getFilteredEquipment` para aplicar a lógica de filtragem combinada.
Memoizada para recalcular apenas quando os critérios de filtro ou `allEquipment` mudarem.

##

### Examples

````javascript
// Diagrama de Estrutura do Hook e suas Dependências:
```mermaid
  classDiagram
    class UseLayerManagerProps {
      +executeCommand(command: Command): void
    }
    class UseLayerManagerReturn {
      +layers: Layer[]
      +handleToggleLayer(layerId: string): void
    }
    class Command {
      +id: string
      +type: string
      +description: string
      +execute(): void
      +undo(): void
    }
    class Layer {
      +id: string
      +name: string
      +equipmentType: string
      +isVisible: boolean
    }
    UseLayerManagerProps ..> Command
    UseLayerManagerReturn ..> Layer
    class useLayerManager {
      -layers: Layer[]
      +handleToggleLayer()
    }
    useLayerManager --|> UseLayerManagerReturn : returns
    useLayerManager ..> Command : uses (via executeCommand)
    useLayerManager ..> initialLayers_data : initializes with
    class initialLayers_data {
    }
```
````

## UseLayerManagerProps

Props para o hook `useLayerManager`.

## UseLayerManagerReturn

Retorno do hook `useLayerManager`.

### Properties

*   `layers` **[Array][415]<[Layer][392]>** A lista atual de todas as camadas e seus respectivos estados de visibilidade.

## useLayerManager

Hook customizado para gerenciar o estado das camadas de visibilidade da cena e sua manipulação.
Inicializa as camadas com os dados de `initialLayers` e permite alternar a visibilidade
de cada camada, registrando a ação no histórico de comandos para suportar undo/redo.

### Parameters

*   `props` **[UseLayerManagerProps][325]** As props do hook, principalmente `executeCommand` para
    integração com o sistema de histórico.

    *   `props.executeCommand` &#x20;

Returns **[UseLayerManagerReturn][326]** Um objeto contendo o estado atual das camadas e a função
para alternar sua visibilidade.

## handleToggleLayer

Manipula a alternância de visibilidade de uma camada específica.
Encontra a camada pelo `layerId`, cria um novo estado de camadas com a visibilidade
da camada alvo invertida, e então cria e executa um comando para o histórico de Undo/Redo
que aplicará essa mudança (e permitirá revertê-la).

### Parameters

*   `layerId` **[string][413]** O ID da camada cuja visibilidade deve ser alternada.

## raycaster

### Examples

````javascript
// Diagrama de Composição e Dependências:
```mermaid
  classDiagram
    class UseMouseInteractionManagerProps {
      +mountRef: RefObject_HTMLDivElement_
      +cameraRef: RefObject_PerspectiveCamera_
      +equipmentMeshesRef: RefObject_Object3D_Array_
      +isSceneReady: boolean
      +onSelectEquipment(tag: string | null, isMultiSelect: boolean): void
      +setHoveredEquipmentTag(tag: string | null): void
    }
    class useMouseInteractionManager {

    }
    class ReactFCHook {

    }
    class RefObject_HTMLDivElement_ {
    }
    class RefObject_PerspectiveCamera_ {
    }
    class RefObject_Object3D_Array_ {
    }
    useMouseInteractionManager --|> ReactFCHook
    UseMouseInteractionManagerProps ..> RefObject_HTMLDivElement_
    UseMouseInteractionManagerProps ..> RefObject_PerspectiveCamera_
    UseMouseInteractionManagerProps ..> RefObject_Object3D_Array_
```
````

## useMouseInteractionManager

Hook customizado para gerenciar interações do mouse (clique e movimento)
para seleção e hover de equipamentos em uma cena Three.js.

### Parameters

*   `props` **UseMouseInteractionManagerProps** As props do hook.

    *   `props.mountRef` &#x20;
    *   `props.cameraRef` &#x20;
    *   `props.equipmentMeshesRef` &#x20;
    *   `props.isSceneReady` &#x20;
    *   `props.onSelectEquipment` &#x20;
    *   `props.setHoveredEquipmentTag` &#x20;

Returns **void**&#x20;

## processSceneClickInternal

Processa um evento de clique do mouse na cena para selecionar equipamento.

## processSceneMouseMoveInternal

Processa um evento de movimento do mouse na cena para detectar equipamento em hover.

##

### Examples

````javascript
// Diagrama de Composição e Dependências:
```mermaid
  classDiagram
    class UseSceneOutlineProps {
      +outlinePassRef: RefObject_OutlinePass_
      +equipmentMeshesRef: RefObject_Object3D_Array_
      +selectedEquipmentTags: string[] | undefined
      +hoveredEquipmentTag: string | null | undefined
      +isSceneReady: boolean
    }
    class RefObject_OutlinePass_ {
      current: OutlinePass | null
    }
    class RefObject_Object3D_Array_ {
      current: THREE.Object3D[] | null
    }
    class useSceneOutline {

    }
    class postprocessing_utils_module {
      +updateOutlineEffect()
    }
    useSceneOutline ..> postprocessing_utils_module : uses updateOutlineEffect
    UseSceneOutlineProps --> RefObject_OutlinePass_
    UseSceneOutlineProps --> RefObject_Object3D_Array_
```
````

## UseSceneOutlineProps

Props para o hook useSceneOutline.

### Properties

*   `outlinePassRef` **React.RefObject<(OutlinePass | null)>** Ref para a instância do OutlinePass.
*   `equipmentMeshesRef` **React.RefObject<[Array][415]\<THREE.Object3D>>** Ref para o array de meshes de equipamentos na cena.
*   `selectedEquipmentTags` **([Array][415]<[string][413]> | [undefined][416])** Array de tags dos equipamentos selecionados.
*   `hoveredEquipmentTag` **([string][413] | null | [undefined][416])** Tag do equipamento atualmente em hover.
*   `isSceneReady` **[boolean][414]** Flag indicando se a cena 3D está pronta.

## useSceneOutline

Hook customizado para gerenciar e aplicar o efeito de contorno (OutlinePass)
aos equipamentos selecionados ou em hover na cena 3D.

### Parameters

*   `props` **[UseSceneOutlineProps][340]** As props para o hook.

    *   `props.outlinePassRef` &#x20;
    *   `props.equipmentMeshesRef` &#x20;
    *   `props.selectedEquipmentTags` &#x20;
    *   `props.hoveredEquipmentTag` &#x20;
    *   `props.isSceneReady` &#x20;

Returns **void**&#x20;

## UseSceneSetupProps

Props para o hook orquestrador da configuração da cena.

### Properties

*   `mountRef` **React.RefObject<[HTMLDivElement][441]>** Ref para o elemento DOM contêiner da cena.

## UseSceneSetupReturn

Valor de retorno do hook orquestrador da configuração da cena.
Agrega refs e flags de prontidão dos hooks especializados.

### Properties

*   `sceneRef` **React.RefObject<(THREE.Scene | null)>** Ref para a cena Three.js.
*   `cameraRef` **React.RefObject<(THREE.PerspectiveCamera | null)>** Ref para a câmera perspectiva.
*   `rendererRef` **React.RefObject<(THREE.WebGLRenderer | null)>** Ref para o renderizador WebGL.
*   `labelRendererRef` **React.RefObject<(CSS2DRenderer | null)>** Ref para o renderizador CSS2D (para rótulos).
*   `controlsRef` **React.RefObject<(OrbitControlsType | null)>** Ref para os OrbitControls.
*   `composerRef` **React.RefObject<(EffectComposer | null)>** Ref para o EffectComposer (pós-processamento).
*   `outlinePassRef` **React.RefObject<(OutlinePass | null)>** Ref para o OutlinePass (efeito de contorno).
*   `groundMeshRef` **React.RefObject<(THREE.Mesh | null)>** Ref para a malha do plano de chão.
*   `isSceneReady` **[boolean][414]** Flag que indica se os componentes principais da cena (núcleo, renderizadores, elementos) estão prontos.
*   `isControlsReady` **[boolean][414]** Flag que indica se os OrbitControls estão prontos (carregamento dinâmico).

## useSceneSetup

Orquestra a configuração de uma cena Three.js compondo hooks especializados.
Este hook é responsável por inicializar o núcleo da cena, renderizadores, controles,
elementos básicos da cena (iluminação, chão) e manipulação de redimensionamento.
Ele fornece refs para todos os principais componentes Three.js e flags indicando sua prontidão.

### Parameters

*   `props` **[UseSceneSetupProps][344]** Propriedades de configuração para a montagem da cena.

Returns **[UseSceneSetupReturn][346]** Refs para os componentes da cena e flags de prontidão.

##

*   **See**: [../../documentation/api/core/repository/memory-repository/README.md#annotationrepository][442] Para a fonte de dados das anotações.
*   **See**: [../../documentation/api/core/repository/memory-repository/README.md#equipmentrepository][443] Para obter dados de equipamentos (e.g., nome para toasts).
*   **See**: [../../documentation/api/lib/types/README.md#Annotation][444] Para a interface de Anotação.
*   **See**: [../../documentation/api/lib/types/README.md#Equipment][445] Para a interface de Equipamento.

### Examples

````javascript
// Diagrama de Interação do useAnnotationManager:
* ```mermaid
graph TD
    A[Componente UI (ex: InfoPanel)] -- chama --> B(handleOpenAnnotationDialog)
    B -- define estados --> DialogState["isAnnotationDialogOpen, editingAnnotation, annotationTargetEquipment"]

    C[Componente UI (ex: AnnotationDialog)] -- no submit --> D(handleSaveAnnotation)

    subgraph useAnnotationManager [Hook useAnnotationManager]
        direction LR
        D -- chama --> E[annotationRepository.addOrUpdateAnnotation]
        E -- retorna --> D{Anotação Salva}
        D -- chama --> F[refreshAnnotationsFromRepo]
        F -- chama --> G[annotationRepository.getAllAnnotations]
        G -- retorna --> H[setAnnotationsState (Estado React)]
        H -- atualiza --> I[annotations (Estado React)]
        D -- chama --> J[toast]
        DialogState
    end

    I -- usado por --> A
    DialogState -- usado por --> C

   classDef hook fill:#lightblue,stroke:#333,stroke-width:2px;
   classDef state fill:#lightgoldenrodyellow,stroke:#333,stroke-width:2px;
   classDef func fill:#lightgreen,stroke:#333,stroke-width:2px;
   classDef repo fill:#lightcoral,stroke:#333,stroke-width:2px;
   classDef ui fill:#peachpuff,stroke:#333,stroke-width:2px;

   class A,C ui;
   class B,D,F,J func;
   class E,G repo;
   class DialogState,H,I state;
   class useAnnotationManager hook;
* ```
````

##

*   **See**: [../../documentation/api/lib/types/README.md#CameraState][446] Para a interface do estado da câmera.
*   **See**: [../../documentation/api/lib/types/README.md#Command][447] Para a interface de comando (usada com `executeCommand`).
*   **See**: [../../documentation/api/lib/types/README.md#TargetSystemInfo][448] Para a interface de informações do sistema alvo.

### Examples

````javascript
// Diagrama de Interação e Estado do useCameraManager:
* ```mermaid
graph LR
    A[Terminal3DPage] -- chama --> B(handleSetCameraViewForSystem)
    B -- atualiza --> C{targetSystemToFrame};
    C -- atualiza --> D{focusedSystemNameUI};
    C -- atualiza --> E{currentViewIndexUI};
    A -- passa targetSystemToFrame --> F[ThreeScene]

    F -- anima câmera e ao final chama --> G(onSystemFramed)
    G -- limpa --> C;
    F -- em interações manuais, chama --> H(handleCameraChangeFromScene)

    H -- cria comando --> I{Comando}
    H -- chama --> J(executeCommand)
    J -- executa e salva --> I

    subgraph useCameraManager [Hook useCameraManager]
        direction LR
        B
        G
        H
        C
        D
        E
        K[currentCameraState (Estado React)]
        L[lastCommittedCameraStateForUndoRef (Ref)]
    end

    I -- no execute/undo --> M{setCurrentCameraState}
    M -- atualiza --> K
    K -- usado por --> F

   classDef hook fill:#lightblue,stroke:#333,stroke-width:2px;
   classDef state fill:#lightgoldenrodyellow,stroke:#333,stroke-width:2px;
   classDef func fill:#lightgreen,stroke:#333,stroke-width:2px;
   classDef comp fill:#lightcoral,stroke:#333,stroke-width:2px;

   class A,F comp;
   class B,G,H,J,M func;
   class C,D,E,K,L,I state;
   class useCameraManager hook;
* ```
````

##

*   **See**: [../../documentation/api/core/repository/memory-repository/README.md#equipmentrepository][443] Para a fonte de dados.
*   **See**: [../../documentation/api/lib/types/README.md#Equipment][445] Para a interface de Equipamento.

### Examples

````javascript
// Diagrama de Interação do useEquipmentDataManager:
* ```mermaid
graph TD
    A[Componente UI (ex: InfoPanel)] -- chama --> B(handleOperationalStateChange)

    subgraph useEquipmentDataManager [Hook useEquipmentDataManager]
        direction LR
        B -- chama --> C[equipmentRepository.updateEquipment]
        C -- retorna --> B{Equipamento Atualizado}
        B -- chama --> D[equipmentRepository.getAllEquipment]
        D -- retorna --> E[setEquipmentData (Estado React)]
        E -- atualiza --> F[equipmentData (Estado React)]
        B -- chama --> G[toast]
    end

    F -- usado por --> A

   classDef hook fill:#lightblue,stroke:#333,stroke-width:2px;
   classDef state fill:#lightgoldenrodyellow,stroke:#333,stroke-width:2px;
   classDef func fill:#lightgreen,stroke:#333,stroke-width:2px;
   classDef repo fill:#lightcoral,stroke:#333,stroke-width:2px;
   classDef ui fill:#peachpuff,stroke:#333,stroke-width:2px;

   class A ui;
   class B,G func;
   class C,D repo;
   class E,F state;
   class useEquipmentDataManager hook;
* ```
````

## useRef

### Examples

````javascript
// Diagrama de Responsabilidade do useThreeCore:
```mermaid
graph TD
    useThreeCore["useThreeCore (Hook)"]
    Props["UseThreeCoreProps"]
    Return["UseThreeCoreReturn"]
    Scene["THREE.Scene"]
    Camera["THREE.PerspectiveCamera"]
    MountElement["Elemento DOM (para aspect ratio)"]

    Props --> useThreeCore
    useThreeCore -- cria --> Scene
    useThreeCore -- cria e configura com base em --> MountElement
    useThreeCore -- cria e configura --> Camera
    useThreeCore -- retorna refs para --> Return
    Return -- contém ref para --> Scene
    Return -- contém ref para --> Camera

    Props -- define --> PInitialPos["initialCameraPosition"]
    Props -- define --> PMountRef["mountRef"]

    classDef hook fill:#lightblue,stroke:#333,stroke-width:2px;
    classDef type fill:#lightgoldenrodyellow,stroke:#333,stroke-width:2px;
    classDef obj3d fill:#lightgreen,stroke:#333,stroke-width:2px;
    classDef dom fill:#lightcoral,stroke:#333,stroke-width:2px;

    class useThreeCore hook;
    class Props,Return,PInitialPos,PMountRef type;
    class Scene,Camera obj3d;
    class MountElement dom;
```
````

Returns **any** Refs para os objetos de cena e câmera criados.

## useRef

### Examples

````javascript
// Diagrama de Fluxo do useThreeOrbitControls:
```mermaid
sequenceDiagram
    participant Usuário
    participant ThreeScene as Componente React
    participant useThreeOrbitControls as Hook
    participant OrbitControls as Módulo Three.js

    ThreeScene ->>+ useThreeOrbitControls: Chama com cameraRef, rendererRef, etc.
    Note right of useThreeOrbitControls: renderersReady = true?
    useThreeOrbitControls ->>+ OrbitControls: import('OrbitControls.js')
    OrbitControls -->>- useThreeOrbitControls: Módulo carregado
    useThreeOrbitControls -->> OrbitControls: new OrbitControls(camera, renderer.domElement)
    useThreeOrbitControls -->> OrbitControls: Configura (enableDamping, target, mouseButtons)
    useThreeOrbitControls -->> OrbitControls: addEventListener('end', handleEnd)
    useThreeOrbitControls -->> ThreeScene: Retorna controlsRef, isControlsReady = true
    activate Usuário
    Usuário ->> OrbitControls: Interage com a câmera (arrasta mouse)
    OrbitControls -->> OrbitControls: Atualiza posição/rotação da câmera
    Usuário ->> OrbitControls: Solta o botão do mouse
    deactivate Usuário
    OrbitControls -->> useThreeOrbitControls: Dispara evento 'end'
    useThreeOrbitControls ->> ThreeScene: Chama onCameraChange(novoEstado)
    Note right of ThreeScene: Atualiza estado da câmera da aplicação
```
````

Returns **any** Ref para a instância de `OrbitControls` e uma flag indicando sua prontidão.

## useRef

### Examples

````javascript
// Diagrama de Componentes Criados por useThreeRenderers:
```mermaid
graph TD
    useThreeRenderers["useThreeRenderers (Hook)"]
    Props["UseThreeRenderersProps"]
    Return["UseThreeRenderersReturn"]

    subgraph "Objetos Three.js Gerenciados"
        WebGLRenderer["THREE.WebGLRenderer"]
        CSS2DRenderer["THREE.CSS2DRenderer"]
        EffectComposer["THREE.EffectComposer"]
        RenderPass["THREE.RenderPass"]
        OutlinePass["THREE.OutlinePass"]
    end

    Props -- define --> PExistingSceneRef["sceneRef (existente)"]
    Props -- define --> PExistingCameraRef["cameraRef (existente)"]
    Props -- define --> PMountRef["mountRef (DOM)"]

    useThreeRenderers -- usa --> PExistingSceneRef
    useThreeRenderers -- usa --> PExistingCameraRef
    useThreeRenderers -- anexa ao --> PMountRef

    useThreeRenderers -- cria e configura --> WebGLRenderer
    useThreeRenderers -- cria e configura --> CSS2DRenderer
    useThreeRenderers -- cria e configura --> EffectComposer
    EffectComposer -- contém --> RenderPass
    EffectComposer -- contém --> OutlinePass

    Return -- contém ref para --> WebGLRenderer
    Return -- contém ref para --> CSS2DRenderer
    Return -- contém ref para --> EffectComposer
    Return -- contém ref para --> OutlinePass
    Return -- contém --> FAreRenderersReady["areRenderersReady (flag)"]

    classDef hook fill:#lightblue,stroke:#333,stroke-width:2px;
    classDef type fill:#lightgoldenrodyellow,stroke:#333,stroke-width:2px;
    classDef obj3d fill:#lightgreen,stroke:#333,stroke-width:2px;
    classDef dom fill:#lightcoral,stroke:#333,stroke-width:2px;
    classDef flag fill:#lightpink,stroke:#333,stroke-width:2px;

    class useThreeRenderers hook;
    class Props,Return,PExistingSceneRef,PExistingCameraRef,PMountRef type;
    class WebGLRenderer,CSS2DRenderer,EffectComposer,RenderPass,OutlinePass obj3d;
    class FAreRenderersReady flag;
```
````

Returns **any** Refs para os renderizadores, composer, outline pass, e uma flag indicando sua prontidão.

## useRef

*   **See**: [https://github.com/Dicommunitas/ThreeJS\_Terminal\_3D/blob/main/documentation/api/core/three/scene-elements-setup/README.md#setupLighting][449] Para a função de configuração da iluminação.
*   **See**: [https://github.com/Dicommunitas/ThreeJS\_Terminal\_3D/blob/main/documentation/api/core/three/scene-elements-setup/README.md#setupGroundPlane][450] Para a função de configuração do plano de chão.

### Examples

```javascript
// Diagrama de Funcionalidade do useThreeSceneElements:
\`\`\`mermaid
graph TD
    useThreeSceneElements["useThreeSceneElements (Hook)"]
    Props["UseThreeSceneElementsProps"]
    Return["UseThreeSceneElementsReturn"]
    SceneRef_Prop["sceneRef (da Cena Principal)"]
    CoreReady_Flag["coreReady (flag)"]
    Utils_Module["scene-elements-setup Utilities"]
    Lighting_Elements["Iluminação (Ambient, Hemisphere, Directional)"]
    GroundPlane_Mesh["Plano de Chão (THREE.Mesh)"]

    Props -- define --> SceneRef_Prop
    Props -- define --> CoreReady_Flag
    Props --> useThreeSceneElements

    useThreeSceneElements -- verifica --> CoreReady_Flag
    useThreeSceneElements -- usa --> SceneRef_Prop
    useThreeSceneElements -- chama --> Utils_Module
    Utils_Module -- adiciona à cena --> Lighting_Elements
    Utils_Module -- cria e adiciona à cena --> GroundPlane_Mesh

    useThreeSceneElements -- retorna ref para --> Return
    Return -- contém ref para --> GroundPlane_Mesh

    classDef hook fill:#lightblue,stroke:#333,stroke-width:2px;
    classDef type fill:#lightgoldenrodyellow,stroke:#333,stroke-width:2px;
    classDef obj3d fill:#lightgreen,stroke:#333,stroke-width:2px;
    classDef util fill:#lightcoral,stroke:#333,stroke-width:2px;
    classDef flag fill:#lightpink,stroke:#333,stroke-width:2px;

    class useThreeSceneElements hook;
    class Props,Return,SceneRef_Prop type;
    class CoreReady_Flag flag;
    class Lighting_Elements,GroundPlane_Mesh obj3d;
    class Utils_Module util;
\`\`\`
```

## UseThreeCoreProps

Props para o hook `useThreeCore`.

### Properties

*   `mountRef` **React.RefObject<([HTMLDivElement][441] | null)>** Ref para o elemento DOM contêiner da cena,
    usado para calcular a razão de aspecto inicial da câmera.

## UseThreeCoreReturn

Valor de retorno do hook `useThreeCore`.

### Properties

*   `sceneRef` **React.RefObject<(THREE.Scene | null)>** Ref para o objeto `THREE.Scene` criado.
*   `cameraRef` **React.RefObject<(THREE.PerspectiveCamera | null)>** Ref para o objeto `THREE.PerspectiveCamera` criado.

## useThreeCore

Inicializa o núcleo da cena Three.js (cena e câmera perspectiva).

### Parameters

*   `props` **[UseThreeCoreProps][364]** Propriedades para a configuração do núcleo.

    *   `props.initialCameraPosition` &#x20;
    *   `props.mountRef` &#x20;

Returns **[UseThreeCoreReturn][366]** Refs para a cena e a câmera.

## UseThreeOrbitControlsProps

Props para o hook `useThreeOrbitControls`.

### Properties

*   `cameraRef` **React.RefObject<(THREE.PerspectiveCamera | null)>** Ref para a câmera perspectiva.
*   `rendererRef` **React.RefObject<(THREE.WebGLRenderer | null)>** Ref para o renderizador WebGL (necessário para o `domElement`).
*   `renderersReady` **[boolean][414]** Flag que indica se os renderizadores (especialmente o `domElement` do WebGLRenderer) estão prontos.

## UseThreeOrbitControlsReturn

Valor de retorno do hook `useThreeOrbitControls`.

### Properties

*   `controlsRef` **React.RefObject<(OrbitControlsType | null)>** Ref para a instância de `OrbitControls`.
*   `isControlsReady` **[boolean][414]** Flag que indica se os `OrbitControls` foram carregados e inicializados com sucesso.

## useThreeOrbitControls

Configura e gerencia os `OrbitControls` do Three.js.
Lida com importação dinâmica, configuração e ouvintes de eventos para mudanças na câmera.

### Parameters

*   `props` **[UseThreeOrbitControlsProps][370]** Propriedades para a configuração dos OrbitControls.

    *   `props.cameraRef` &#x20;
    *   `props.rendererRef` &#x20;
    *   `props.initialCameraLookAt` &#x20;
    *   `props.onCameraChange` &#x20;
    *   `props.renderersReady` &#x20;

Returns **[UseThreeOrbitControlsReturn][372]** Ref para os OrbitControls e flag de prontidão.

## UseThreeRenderersProps

Props para o hook `useThreeRenderers`.

### Properties

*   `mountRef` **React.RefObject<([HTMLDivElement][441] | null)>** Ref para o elemento DOM onde os renderizadores serão montados.
*   `sceneRef` **React.RefObject<(THREE.Scene | null)>** Ref para a cena Three.js existente.
*   `cameraRef` **React.RefObject<(THREE.PerspectiveCamera | null)>** Ref para a câmera perspectiva existente.

## UseThreeRenderersReturn

Valor de retorno do hook `useThreeRenderers`.

### Properties

*   `rendererRef` **React.RefObject<(THREE.WebGLRenderer | null)>** Ref para o `WebGLRenderer`.
*   `labelRendererRef` **React.RefObject<(CSS2DRenderer | null)>** Ref para o `CSS2DRenderer`.
*   `composerRef` **React.RefObject<(EffectComposer | null)>** Ref para o `EffectComposer`.
*   `outlinePassRef` **React.RefObject<(OutlinePass | null)>** Ref para o `OutlinePass`.
*   `areRenderersReady` **[boolean][414]** Flag que indica se todos os renderizadores e o composer foram inicializados com sucesso.

## useThreeRenderers

Configura os renderizadores Three.js (WebGL, CSS2D) e o pipeline de pós-processamento (EffectComposer, OutlinePass).
Gerencia a anexação ao DOM e eventos de contexto WebGL.

### Parameters

*   `props` **[UseThreeRenderersProps][376]** Propriedades para a configuração dos renderizadores.

    *   `props.mountRef` &#x20;
    *   `props.sceneRef` &#x20;
    *   `props.cameraRef` &#x20;

Returns **[UseThreeRenderersReturn][378]** Refs para os renderizadores, composer, outline pass, e flag de prontidão.

## UseThreeResizeProps

Props para o hook `useThreeResize`.

### Properties

*   `mountRef` **React.RefObject<([HTMLDivElement][441] | null)>** Ref para o elemento DOM contêiner da cena.
*   `cameraRef` **React.RefObject<(THREE.PerspectiveCamera | null)>** Ref para a câmera perspectiva.
*   `rendererRef` **React.RefObject<(THREE.WebGLRenderer | null)>** Ref para o renderizador WebGL.
*   `labelRendererRef` **React.RefObject<(CSS2DRenderer | null)>** Ref para o renderizador CSS2D.
*   `composerRef` **React.RefObject<(EffectComposer | null)>** Ref para o EffectComposer.
*   `outlinePassRef` **React.RefObject<(OutlinePass | null)>** Ref para o OutlinePass.
*   `ready` **[boolean][414]** Flag que indica se todos os componentes que precisam ser redimensionados estão prontos.

## useThreeResize

Lida com eventos de redimensionamento para a cena Three.js, atualizando câmera e renderizadores.

### Parameters

*   `props` **[UseThreeResizeProps][382]** Refs para elementos que precisam ser redimensionados e uma flag de prontidão.

    *   `props.mountRef` &#x20;
    *   `props.cameraRef` &#x20;
    *   `props.rendererRef` &#x20;
    *   `props.labelRendererRef` &#x20;
    *   `props.composerRef` &#x20;
    *   `props.outlinePassRef` &#x20;
    *   `props.ready` &#x20;

Returns **void**&#x20;

## UseThreeSceneElementsProps

Props para o hook `useThreeSceneElements`.

### Properties

*   `sceneRef` **React.RefObject<(THREE.Scene | null)>** Ref para o objeto `THREE.Scene` onde os elementos serão adicionados.
*   `coreReady` **[boolean][414]** Flag que indica se o núcleo da cena (incluindo `sceneRef.current`) está pronto.

## UseThreeSceneElementsReturn

Valor de retorno do hook `useThreeSceneElements`.

### Properties

*   `groundMeshRef` **React.RefObject<(THREE.Mesh | null)>** Ref para a malha (mesh) do plano de chão criada.

## useThreeSceneElements

Configura elementos básicos da cena, como iluminação e plano de chão.

### Parameters

*   `props` **[UseThreeSceneElementsProps][386]** Propriedades para a configuração dos elementos da cena.

    *   `props.sceneRef` &#x20;
    *   `props.coreReady` &#x20;

Returns **[UseThreeSceneElementsReturn][388]** Ref para a malha do plano de chão.

## Layer

Representa uma camada de visualização na interface do usuário.
Camadas permitem ao usuário controlar a visibilidade de grupos de equipamentos
ou outros elementos da cena (como anotações ou o terreno).

### Properties

*   `id` **[string][413]** Identificador único da camada (e.g., 'layer-tanks', 'layer-annotations').
*   `name` **[string][413]** Nome legível da camada para exibição na UI (e.g., "Tanques", "Anotações").
*   `isVisible` **[boolean][414]** Indica se a camada (e os elementos que ela controla) está atualmente visível.

## CameraState

Representa o estado da câmera 3D, definido por sua posição e o ponto para o qual está olhando.

## SystemView

Alias para CameraState, usado para clareza ao descrever uma visão específica do sistema.

Type: [CameraState][394]

## SystemViewOptions

Define as diferentes opções de visualização para um sistema focado.

### Properties

*   `default` **[SystemView][395]** A visão padrão calculada.
*   `topDown` **[SystemView][395]?** Uma visão de cima para baixo.
*   `isometric` **[SystemView][395]?** Uma visão isométrica simulada.

## TargetSystemInfo

Informações sobre o sistema alvo para o qual a câmera deve ser enquadrada,
incluindo o índice da visão desejada.

### Properties

*   `systemName` **[string][413]** O nome do sistema a ser focado.
*   `viewIndex` **[number][427]** O índice da visualização desejada (0 para padrão, 1 para top-down, etc.).

## Annotation

Representa uma anotação textual associada a um equipamento específico.
Cada equipamento pode ter no máximo uma anotação.

### Properties

*   `equipmentTag` **[string][413]** A tag do equipamento ao qual esta anotação está vinculada.
    Serve como chave estrangeira para o objeto `Equipment`.
*   `text` **[string][413]** O conteúdo textual da anotação.
*   `createdAt` **[string][413]** Data e hora em formato string ISO 8601 (e.g., "2023-10-27T10:30:00.000Z")
    indicando quando a anotação foi criada ou atualizada pela última vez.

## ColorMode

Define os modos de colorização disponíveis para os equipamentos na cena 3D.
O usuário pode selecionar um desses modos para alterar a forma como os equipamentos são coloridos.

*   **'Produto'**: Colore os equipamentos com base no produto que eles manipulam/contêm.
    A cor é gerada proceduralmente a partir do código do produto.
*   **'Estado Operacional'**: Colore os equipamentos com base em seu estado operacional atual
    (e.g., 'operando', 'manutenção', 'em falha').
*   **'Equipamento'**: Utiliza a cor base definida individualmente para cada equipamento
    em seus dados (`Equipment.color`).

Type: (`"Produto"` | `"Estado Operacional"` | `"Equipamento"`)

[1]: #

[2]: #examples

[3]: #terminal3dpage

[4]: #handlefocusandselectsystem

[5]: #parameters

[6]: #-1

[7]: #annotationdialogprops

[8]: #properties

[9]: #annotationdialog

[10]: #parameters-1

[11]: #useeffect

[12]: #useeffect-1

[13]: #parameters-2

[14]: #examples-1

[15]: #handleconfirm

[16]: #-2

[17]: #cameracontrolspanelprops

[18]: #properties-1

[19]: #cameracontrolspanel

[20]: #parameters-3

[21]: #-3

[22]: #colormodeselectorprops

[23]: #properties-2

[24]: #colormodeselector

[25]: #parameters-4

[26]: #-4

[27]: #commandhistorypanelprops

[28]: #properties-3

[29]: #commandhistorypanel

[30]: #parameters-5

[31]: #-5

[32]: #infopanelprops

[33]: #equipment

[34]: #annotation

[35]: #onclose

[36]: #onopenannotationdialog

[37]: #ondeleteannotation

[38]: #onoperationalstatechange

[39]: #availableoperationalstateslist

[40]: #onproductchange

[41]: #availableproductslist

[42]: #infopanel

[43]: #parameters-6

[44]: #handledeleteclick

[45]: #formatteddate

[46]: #-6

[47]: #layermanagerprops

[48]: #properties-4

[49]: #layermanager

[50]: #parameters-7

[51]: #-7

[52]: #mainsceneareaprops

[53]: #properties-5

[54]: #mainscenearea

[55]: #parameters-8

[56]: #-8

[57]: #sidebarcontentlayoutprops

[58]: #properties-6

[59]: #sidebarcontentlayout

[60]: #parameters-9

[61]: #terminal

[62]: #siteheader

[63]: #-9

[64]: #examples-2

[65]: #threesceneprops

[66]: #properties-7

[67]: #threescene

[68]: #parameters-10

[69]: #themes

[70]: #chartconfig

[71]: #examples-3

[72]: #form

[73]: #parameters-11

[74]: #examples-4

[75]: #-10

[76]: #usesidebar

[77]: #sidebarprovider

[78]: #defaultopen

[79]: #open

[80]: #onopenchange

[81]: #sidebar

[82]: #side

[83]: #variant

[84]: #collapsible

[85]: #sidebartrigger

[86]: #sidebarrail

[87]: #sidebarinset

[88]: #sidebarinput

[89]: #sidebarheader

[90]: #sidebarfooter

[91]: #sidebarseparator

[92]: #sidebarcontent

[93]: #sidebargroup

[94]: #sidebargrouplabel

[95]: #sidebargroupaction

[96]: #sidebargroupcontent

[97]: #sidebarmenu

[98]: #sidebarmenuitem

[99]: #sidebarmenubutton

[100]: #isactive

[101]: #tooltip

[102]: #sidebarmenuaction

[103]: #showonhover

[104]: #sidebarmenubadge

[105]: #sidebarmenuskeleton

[106]: #showicon

[107]: #sidebarmenusub

[108]: #sidebarmenusubitem

[109]: #sidebarmenusubbutton

[110]: #size

[111]: #isactive-1

[112]: #equipment-1

[113]: #equipment-2

[114]: #equipment-3

[115]: #examples-5

[116]: #equipment-4

[117]: #equipment-5

[118]: #properties-8

[119]: #initialequipment

[120]: #initiallayers

[121]: #initialannotations

[122]: #three

[123]: #three-1

[124]: #examples-6

[125]: #three-2

[126]: #three-3

[127]: #examples-7

[128]: #three-4

[129]: #examples-8

[130]: #three-5

[131]: #examples-9

[132]: #three-6

[133]: #parameters-12

[134]: #examples-10

[135]: #three-7

[136]: #examples-11

[137]: #getcharnumericvalue

[138]: #parameters-13

[139]: #getequipmentcolor

[140]: #parameters-14

[141]: #equipmentfiltercriteria

[142]: #properties-9

[143]: #getfilteredequipment

[144]: #parameters-15

[145]: #equipmentrepository

[146]: #getequipmentbytag

[147]: #parameters-16

[148]: #getallequipment

[149]: #addequipment

[150]: #parameters-17

[151]: #updateequipment

[152]: #parameters-18

[153]: #deleteequipment

[154]: #parameters-19

[155]: #annotationrepository

[156]: #getannotationbyequipmenttag

[157]: #parameters-20

[158]: #getallannotations

[159]: #addorupdateannotation

[160]: #parameters-21

[161]: #deleteannotation

[162]: #parameters-22

[163]: #initializeannotations

[164]: #parameters-23

[165]: #calculateviewformeshes

[166]: #parameters-24

[167]: #creategeometryforitem

[168]: #parameters-25

[169]: #updatelabelrenderersize

[170]: #parameters-26

[171]: #updateannotationpinsparams

[172]: #properties-10

[173]: #updateannotationpins

[174]: #parameters-27

[175]: #-11

[176]: #setoutlinepassobjects

[177]: #parameters-28

[178]: #applyoutlinepassstyle

[179]: #parameters-29

[180]: #setuppostprocessing

[181]: #parameters-30

[182]: #updatepostprocessingsize

[183]: #parameters-31

[184]: #updateoutlineeffect

[185]: #parameters-32

[186]: #setuplighting

[187]: #parameters-33

[188]: #setupgroundplane

[189]: #parameters-34

[190]: #setuprenderpipeline

[191]: #parameters-35

[192]: #updateequipmentmeshesparams

[193]: #examples-12

[194]: #updateequipmentmeshesinscene

[195]: #parameters-36

[196]: #useanimationloopprops

[197]: #properties-11

[198]: #useanimationloop

[199]: #parameters-37

[200]: #-12

[201]: #parameters-38

[202]: #examples-13

[203]: #useannotationmanagerprops

[204]: #properties-12

[205]: #useannotationmanagerprops-1

[206]: #properties-13

[207]: #useannotationmanagerreturn

[208]: #properties-14

[209]: #useannotationmanagerreturn-1

[210]: #properties-15

[211]: #useannotationmanager

[212]: #parameters-39

[213]: #useannotationmanager-1

[214]: #parameters-40

[215]: #refreshannotationsfromrepo

[216]: #refreshannotationsfromrepo-1

[217]: #handleopenannotationdialog

[218]: #parameters-41

[219]: #handleopenannotationdialog-1

[220]: #parameters-42

[221]: #handlesaveannotation

[222]: #parameters-43

[223]: #handlesaveannotation-1

[224]: #parameters-44

[225]: #handledeleteannotation

[226]: #parameters-45

[227]: #handledeleteannotation-1

[228]: #parameters-46

[229]: #getannotationforequipment

[230]: #parameters-47

[231]: #getannotationforequipment-1

[232]: #parameters-48

[233]: #useannotationpinrendererprops

[234]: #useannotationpinrenderer

[235]: #parameters-49

[236]: #-13

[237]: #parameters-50

[238]: #examples-14

[239]: #defaultinitialcameraposition

[240]: #defaultinitialcameraposition-1

[241]: #defaultinitialcameralookat

[242]: #defaultinitialcameralookat-1

[243]: #usecameramanagerprops

[244]: #usecameramanagerprops-1

[245]: #usecameramanagerreturn

[246]: #properties-16

[247]: #usecameramanagerreturn-1

[248]: #properties-17

[249]: #usecameramanager

[250]: #parameters-51

[251]: #usecameramanager-1

[252]: #parameters-52

[253]: #handlesetcameraviewforsystem

[254]: #parameters-53

[255]: #handlesetcameraviewforsystem-1

[256]: #parameters-54

[257]: #handlecamerachangefromscene

[258]: #parameters-55

[259]: #handlecamerachangefromscene-1

[260]: #parameters-56

[261]: #onsystemframed

[262]: #onsystemframed-1

[263]: #command

[264]: #examples-15

[265]: #command-1

[266]: #properties-18

[267]: #commandhistorystate

[268]: #properties-19

[269]: #usecommandhistoryreturn

[270]: #properties-20

[271]: #usecommandhistory

[272]: #parameters-57

[273]: #executecommand

[274]: #parameters-58

[275]: #undo

[276]: #redo

[277]: #-14

[278]: #examples-16

[279]: #useequipmentdatamanagerreturn

[280]: #properties-21

[281]: #useequipmentdatamanagerreturn-1

[282]: #properties-22

[283]: #useequipmentdatamanager

[284]: #useequipmentdatamanager-1

[285]: #refreshequipmentdata

[286]: #refreshequipmentdata-1

[287]: #handleoperationalstatechange

[288]: #parameters-59

[289]: #handleoperationalstatechange-1

[290]: #parameters-60

[291]: #handleproductchange

[292]: #parameters-61

[293]: #handleproductchange-1

[294]: #parameters-62

[295]: #useequipmentrendererprops

[296]: #examples-17

[297]: #useequipmentrenderer

[298]: #parameters-63

[299]: #-15

[300]: #useequipmentselectionmanagerprops

[301]: #properties-23

[302]: #useequipmentselectionmanagerreturn

[303]: #properties-24

[304]: #useequipmentselectionmanager

[305]: #parameters-64

[306]: #handleequipmentclick

[307]: #parameters-65

[308]: #handlesethoveredequipmenttag

[309]: #parameters-66

[310]: #selecttagsbatch

[311]: #parameters-67

[312]: #-16

[313]: #examples-18

[314]: #usefiltermanagerprops

[315]: #properties-25

[316]: #usefiltermanagerreturn

[317]: #properties-26

[318]: #usefiltermanager

[319]: #parameters-68

[320]: #availablesistemas

[321]: #availableareas

[322]: #filteredequipment

[323]: #-17

[324]: #examples-19

[325]: #uselayermanagerprops

[326]: #uselayermanagerreturn

[327]: #properties-27

[328]: #uselayermanager

[329]: #parameters-69

[330]: #handletogglelayer

[331]: #parameters-70

[332]: #raycaster

[333]: #examples-20

[334]: #usemouseinteractionmanager

[335]: #parameters-71

[336]: #processsceneclickinternal

[337]: #processscenemousemoveinternal

[338]: #-18

[339]: #examples-21

[340]: #usesceneoutlineprops

[341]: #properties-28

[342]: #usesceneoutline

[343]: #parameters-72

[344]: #usescenesetupprops

[345]: #properties-29

[346]: #usescenesetupreturn

[347]: #properties-30

[348]: #usescenesetup

[349]: #parameters-73

[350]: #-19

[351]: #examples-22

[352]: #-20

[353]: #examples-23

[354]: #-21

[355]: #examples-24

[356]: #useref

[357]: #examples-25

[358]: #useref-1

[359]: #examples-26

[360]: #useref-2

[361]: #examples-27

[362]: #useref-3

[363]: #examples-28

[364]: #usethreecoreprops

[365]: #properties-31

[366]: #usethreecorereturn

[367]: #properties-32

[368]: #usethreecore

[369]: #parameters-74

[370]: #usethreeorbitcontrolsprops

[371]: #properties-33

[372]: #usethreeorbitcontrolsreturn

[373]: #properties-34

[374]: #usethreeorbitcontrols

[375]: #parameters-75

[376]: #usethreerenderersprops

[377]: #properties-35

[378]: #usethreerenderersreturn

[379]: #properties-36

[380]: #usethreerenderers

[381]: #parameters-76

[382]: #usethreeresizeprops

[383]: #properties-37

[384]: #usethreeresize

[385]: #parameters-77

[386]: #usethreesceneelementsprops

[387]: #properties-38

[388]: #usethreesceneelementsreturn

[389]: #properties-39

[390]: #usethreesceneelements

[391]: #parameters-78

[392]: #layer

[393]: #properties-40

[394]: #camerastate

[395]: #systemview

[396]: #systemviewoptions

[397]: #properties-41

[398]: #targetsysteminfo

[399]: #properties-42

[400]: #annotation-1

[401]: #properties-43

[402]: #colormode

[403]: https://github.com/Dicommunitas/ThreeJS_Terminal_3D/blob/main/documentation/api/components/main-scene-area/README.md

[404]: https://github.com/Dicommunitas/ThreeJS_Terminal_3D/blob/main/documentation/api/components/ui/sidebar/README.md

[405]: https://github.com/Dicommunitas/ThreeJS_Terminal_3D/blob/main/documentation/api/components/annotation-dialog/README.md

[406]: https://github.com/Dicommunitas/ThreeJS_Terminal_3D/blob/main/documentation/api/hooks/use-command-history/README.md

[407]: https://github.com/Dicommunitas/ThreeJS_Terminal_3D/blob/main/documentation/api/hooks/use-equipment-data-manager/README.md

[408]: https://github.com/Dicommunitas/ThreeJS_Terminal_3D/blob/main/documentation/api/hooks/use-camera-manager/README.md

[409]: https://github.com/Dicommunitas/ThreeJS_Terminal_3D/blob/main/documentation/api/hooks/use-filter-manager/README.md

[410]: https://github.com/Dicommunitas/ThreeJS_Terminal_3D/blob/main/documentation/api/hooks/use-annotation-manager/README.md

[411]: https://github.com/Dicommunitas/ThreeJS_Terminal_3D/blob/main/documentation/api/hooks/use-equipment-selection-manager/README.md

[412]: https://github.com/Dicommunitas/ThreeJS_Terminal_3D/blob/main/documentation/api/hooks/use-layer-manager/README.md

[413]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String

[414]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Boolean

[415]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array

[416]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/undefined

[417]: https://github.com/Dicommunitas/ThreeJS_Terminal_3D/blob/main/documentation/api/hooks/use-scene-setup/README.md

[418]: https://github.com/Dicommunitas/ThreeJS_Terminal_3D/blob/main/documentation/api/hooks/use-equipment-renderer/README.md

[419]: https://github.com/Dicommunitas/ThreeJS_Terminal_3D/blob/main/documentation/api/hooks/use-annotation-pin-renderer/README.md

[420]: https://github.com/Dicommunitas/ThreeJS_Terminal_3D/blob/main/documentation/api/hooks/use-mouse-interaction/README.md

[421]: https://github.com/Dicommunitas/ThreeJS_Terminal_3D/blob/main/documentation/api/hooks/use-scene-outline/README.md

[422]: https://github.com/Dicommunitas/ThreeJS_Terminal_3D/blob/main/documentation/api/hooks/use-animation-loop/README.md

[423]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Error

[424]: https://github.com/Dicommunitas/ThreeJS_Terminal_3D/blob/main/documentation/api/core/data/initial-data/README.md

[425]: https://github.com/Dicommunitas/ThreeJS_Terminal_3D/blob/main/documentation/api/lib/types/README.md#Equipment

[426]: https://github.com/Dicommunitas/ThreeJS_Terminal_3D/blob/main/documentation/api/lib/types/README.md#Annotation

[427]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number

[428]: https://github.com/Dicommunitas/ThreeJS_Terminal_3D/blob/main/documentation/api/hooks/useThreeCore/README.md

[429]: https://github.com/Dicommunitas/ThreeJS_Terminal_3D/blob/main/documentation/api/hooks/useThreeRenderers/README.md

[430]: https://github.com/Dicommunitas/ThreeJS_Terminal_3D/blob/main/documentation/api/hooks/useThreeOrbitControls/README.md

[431]: https://github.com/Dicommunitas/ThreeJS_Terminal_3D/blob/main/documentation/api/hooks/useThreeSceneElements/README.md

[432]: https://github.com/Dicommunitas/ThreeJS_Terminal_3D/blob/main/documentation/api/hooks/useThreeResize/README.md

[433]: https://developer.mozilla.org/docs/Web/HTML/Element

[434]: ../../core/repository/memory-repository/README.md#annotationRepository

[435]: ../../core/repository/memory-repository/README.md#equipmentRepository

[436]: ../../lib/types/README.md#Annotation

[437]: ../../lib/types/README.md#Equipment

[438]: ../../lib/types/README.md#CameraState

[439]: ../../lib/types/README.md#Command

[440]: ../../lib/types/README.md#TargetSystemInfo

[441]: https://developer.mozilla.org/docs/Web/API/HTMLDivElement

[442]: ../../documentation/api/core/repository/memory-repository/README.md#annotationrepository

[443]: ../../documentation/api/core/repository/memory-repository/README.md#equipmentrepository

[444]: ../../documentation/api/lib/types/README.md#Annotation

[445]: ../../documentation/api/lib/types/README.md#Equipment

[446]: ../../documentation/api/lib/types/README.md#CameraState

[447]: ../../documentation/api/lib/types/README.md#Command

[448]: ../../documentation/api/lib/types/README.md#TargetSystemInfo

[449]: https://github.com/Dicommunitas/ThreeJS_Terminal_3D/blob/main/documentation/api/core/three/scene-elements-setup/README.md#setupLighting

[450]: https://github.com/Dicommunitas/ThreeJS_Terminal_3D/blob/main/documentation/api/core/three/scene-elements-setup/README.md#setupGroundPlane
